{"version":3,"sources":["assets/intl/intl-orig.js"],"names":["global","factory","exports","module","define","amd","IntlPolyfill","this","log10Floor","n","Math","log10","floor","x","round","log","LOG10E","Number","Record","obj","k","hop","call","defineProperty","value","enumerable","writable","configurable","List","arguments","length","arrPush","apply","arrSlice","createRegExpRestore","internals","disableRegExpRestore","regExpCache","lastMatch","RegExp","leftContext","multiline","input","has","i","esc","lm","replace","reg","_i","m","slice","indexOf","exprStr","arrJoin","match","expr","lastIndex","exec","toObject","arg","TypeError","babelHelpers$1","Object","toNumber","toInteger","number","isNaN","Infinity","abs","toLength","len","pow","min","getInternalProperties","__getInternalProperties","secret","objCreate","setDefaultLocale","locale","defaultLocale","toLatinUpperCase","str","ch","charAt","toUpperCase","IsStructurallyValidLanguageTag","expBCP47Syntax","test","expVariantDupes","expSingletonDupes","CanonicalizeLanguageTag","parts","toLowerCase","split","max","expExtSequences","sort","source","redundantTags","tags","_max","subtags","extLang","DefaultLocale","IsWellFormedCurrencyCode","currency","c","String","normalized","expCurrencyCode","CanonicalizeLocaleList","locales","undefined","seen","O","Pk","kPresent","kValue","tag","RangeError","arrIndexOf","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","expUnicodeExSeq","result","extension","extensionIndex","BestFitMatcher","ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","extensionSubtags","extensionSubtagsLength","prototype","supportedExtension","key","foundLocaleData","keyLocaleData","supportedExtensionAddition","keyPos","requestedValue","valuePos","_valuePos","optionsValue","privateIndex","preExtension","postExtension","LookupSupportedLocales","subset","subsetArray","BestFitSupportedLocales","SupportedLocales","localeMatcher","P","GetOption","property","type","values","fallback","Boolean","GetNumberOption","minimum","maximum","getCanonicalLocales","ll","NumberFormatConstructor","Intl$1","InitializeNumberFormat","NumberFormat","numberFormat","internal","regexpRestore","opt","dataLocale","s","cDigits","CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","es3","format","GetFormatNumber","currencyMinorUnits","F","FormatNumber","bf","fnBind","formatToParts","FormatNumberToParts","PartitionNumberPattern","part","nums","data","ild","symbols","latn","pattern","beginIndex","endIndex","nextIndex","Error","literal","[[type]]","[[value]]","p","nan","isFinite","_n2","ToRawPrecision","ToRawFixed","numSys","digits","digit","integer","fraction","decimalSepIndex","groupSepSymbol","group","groups","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","end","idx","start","integerGroup","arrShift","decimalSepSymbol","decimal","_n","infinity","plusSignSymbol","plusSign","minusSignSymbol","minusSign","percentSignSymbol","percentSign","currencies","_literal","_literal2","minPrecision","maxPrecision","e","Array","f","exp","LN10","cut","minInteger","minFraction","maxFraction","toFixed","int","z","a","b","_z","isDateFormatOnly","tmKeys","hasOwnProperty","isTimeFormatOnly","dtKeys","joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","_","j","computeFinalPatterns","formatObj","pattern12","extendedPattern","$0","expPatternTrimmer","expDTComponentsMeta","era","year","quarter","month","week","day","weekday","hour12","hour","minute","second","timeZoneName","createDateTimeFormat","skeleton","unwantedDTCs","originalPattern","expDTComponents","createDateTimeFormats","formats","availableFormats","timeFormats","dateFormats","computed","timeRelatedFormats","dateRelatedFormats","push","full","long","medium","short","generateSyntheticFormat","propName","propValue","validSyntheticProps","_ref2","defineProperty$1","resolveDateString","ca","component","width","gregory","alts","narrow","resolved","DateTimeFormatConstructor","InitializeDateTimeFormat","DateTimeFormat","dateTimeFormat","ToDateTimeOptions","tz","timeZone","prop","dateTimeComponents","bestFormat","ToDateTimeFormats","BasicFormatMatcher","_hr","BestFitFormatMatcher","_prop","hr12","hourNo0","GetFormatDateTime","toString","required","defaults","opt2","create","needDefaults","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","optionsPropNames","_bestFormat","patternPenalty","hour12Penalty","_property","patternProp","date","Date","now","FormatDateTime","formatToParts$1","FormatToPartsDateTime","CreateDateTimeParts","nf","useGrouping","nf2","minimumIntegerDigits","tm","ToLocalTime","index","calendars","fv","v","dateWidths","_v","substr","calendar","d","[[weekday]]","[[era]]","[[year]]","[[month]]","[[day]]","[[hour]]","[[minute]]","[[second]]","[[inDST]]","addLocaleData","nu","_typeof","Symbol","iterator","constructor","jsx","REACT_ELEMENT_TYPE","for","props","children","defaultProps","childrenLength","childArray","$$typeof","ref","_owner","asyncToGenerator","fn","gen","Promise","resolve","reject","step","info","error","done","then","err","classCallCheck","instance","Constructor","createClass","defineProperties","target","descriptor","protoProps","staticProps","defineEnumerableProperties","descs","desc","keys","getOwnPropertyNames","getOwnPropertyDescriptor","_extends","assign","get","object","receiver","Function","parent","getPrototypeOf","getter","inherits","subClass","superClass","setPrototypeOf","__proto__","_instanceof","left","right","hasInstance","interopRequireDefault","__esModule","default","interopRequireWildcard","newObj","newArrowCheck","innerThis","boundThis","objectDestructuringEmpty","objectWithoutProperties","possibleConstructorReturn","self","selfGlobal","set","setter","slicedToArray","sliceIterator","arr","_arr","_d","_e","_s","next","isArray","slicedToArrayLoose","_step","_iterator","taggedTemplateLiteral","strings","raw","freeze","taggedTemplateLiteralLoose","temporalRef","val","name","undef","temporalUndefined","toArray","from","toConsumableArray","arr2","typeof","extends","instanceof","realDefineProp","sentinel","__defineGetter__","search","t","proto","arrConcat","concat","join","shift","bind","thisObj","args","random","extlang","language","script","region","variant","singleton","privateuse","irregular","regular","grandfathered","langtag","art-lojban","i-ami","i-bnn","i-hak","i-klingon","i-lux","i-navajo","i-pwn","i-tao","i-tay","i-tsu","no-bok","no-nyn","sgn-BE-FR","sgn-BE-NL","sgn-CH-DE","zh-guoyu","zh-hakka","zh-min-nan","zh-xiang","sgn-BR","sgn-CO","sgn-DE","sgn-DK","sgn-ES","sgn-FR","sgn-GB","sgn-GR","sgn-IE","sgn-IT","sgn-JP","sgn-MX","sgn-NI","sgn-NL","sgn-NO","sgn-PT","sgn-SE","sgn-US","sgn-ZA","zh-cmn","zh-cmn-Hans","zh-cmn-Hant","zh-gan","zh-wuu","zh-yue","BU","DD","FX","TP","YD","ZR","heploc","in","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","[[availableLocales]]","[[relevantExtensionKeys]]","[[localeData]]","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","numeric","2-digit","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","Intl","window","__applyLocaleSensitivePrototypes"],"mappings":"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AAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,MACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,KAAM,MAAO,OACbC,K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","file":"intl.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.IntlPolyfill = factory());\n}(this, function () { 'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n\n  var jsx = function () {\n    var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n    return function createRawReactElement(type, props, key, children) {\n      var defaultProps = type && type.defaultProps;\n      var childrenLength = arguments.length - 3;\n\n      if (!props && childrenLength !== 0) {\n        props = {};\n      }\n\n      if (props && defaultProps) {\n        for (var propName in defaultProps) {\n          if (props[propName] === void 0) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      } else if (!props) {\n        props = defaultProps || {};\n      }\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 3];\n        }\n\n        props.children = childArray;\n      }\n\n      return {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key === undefined ? null : '' + key,\n        ref: null,\n        props: props,\n        _owner: null\n      };\n    };\n  }();\n\n  var asyncToGenerator = function (fn) {\n    return function () {\n      var gen = fn.apply(this, arguments);\n      return new Promise(function (resolve, reject) {\n        function step(key, arg) {\n          try {\n            var info = gen[key](arg);\n            var value = info.value;\n          } catch (error) {\n            reject(error);\n            return;\n          }\n\n          if (info.done) {\n            resolve(value);\n          } else {\n            return Promise.resolve(value).then(function (value) {\n              return step(\"next\", value);\n            }, function (err) {\n              return step(\"throw\", err);\n            });\n          }\n        }\n\n        return step(\"next\");\n      });\n    };\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var defineEnumerableProperties = function (obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    return obj;\n  };\n\n  var defaults = function (obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n\n    return obj;\n  };\n\n  var defineProperty$1 = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var get = function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  };\n\n  var inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var _instanceof = function (left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  };\n\n  var interopRequireDefault = function (obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  };\n\n  var interopRequireWildcard = function (obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  };\n\n  var newArrowCheck = function (innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  };\n\n  var objectDestructuringEmpty = function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  };\n\n  var objectWithoutProperties = function (obj, keys) {\n    var target = {};\n\n    for (var i in obj) {\n      if (keys.indexOf(i) >= 0) continue;\n      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n      target[i] = obj[i];\n    }\n\n    return target;\n  };\n\n  var possibleConstructorReturn = function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var selfGlobal = typeof global === \"undefined\" ? self : global;\n\n  var set = function set(object, property, value, receiver) {\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent !== null) {\n        set(parent, property, value, receiver);\n      }\n    } else if (\"value\" in desc && desc.writable) {\n      desc.value = value;\n    } else {\n      var setter = desc.set;\n\n      if (setter !== undefined) {\n        setter.call(receiver, value);\n      }\n    }\n\n    return value;\n  };\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var slicedToArrayLoose = function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      var _arr = [];\n\n      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n        _arr.push(_step.value);\n\n        if (i && _arr.length === i) break;\n      }\n\n      return _arr;\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n\n  var taggedTemplateLiteral = function (strings, raw) {\n    return Object.freeze(Object.defineProperties(strings, {\n      raw: {\n        value: Object.freeze(raw)\n      }\n    }));\n  };\n\n  var taggedTemplateLiteralLoose = function (strings, raw) {\n    strings.raw = raw;\n    return strings;\n  };\n\n  var temporalRef = function (val, name, undef) {\n    if (val === undef) {\n      throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n    } else {\n      return val;\n    }\n  };\n\n  var temporalUndefined = {};\n\n  var toArray = function (arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n  };\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n\n\n  var babelHelpers$1 = Object.freeze({\n    jsx: jsx,\n    asyncToGenerator: asyncToGenerator,\n    classCallCheck: classCallCheck,\n    createClass: createClass,\n    defineEnumerableProperties: defineEnumerableProperties,\n    defaults: defaults,\n    defineProperty: defineProperty$1,\n    get: get,\n    inherits: inherits,\n    interopRequireDefault: interopRequireDefault,\n    interopRequireWildcard: interopRequireWildcard,\n    newArrowCheck: newArrowCheck,\n    objectDestructuringEmpty: objectDestructuringEmpty,\n    objectWithoutProperties: objectWithoutProperties,\n    possibleConstructorReturn: possibleConstructorReturn,\n    selfGlobal: selfGlobal,\n    set: set,\n    slicedToArray: slicedToArray,\n    slicedToArrayLoose: slicedToArrayLoose,\n    taggedTemplateLiteral: taggedTemplateLiteral,\n    taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,\n    temporalRef: temporalRef,\n    temporalUndefined: temporalUndefined,\n    toArray: toArray,\n    toConsumableArray: toConsumableArray,\n    typeof: _typeof,\n    extends: _extends,\n    instanceof: _instanceof\n  });\n\n  var realDefineProp = function () {\n      var sentinel = function sentinel() {};\n      try {\n          Object.defineProperty(sentinel, 'a', {\n              get: function get() {\n                  return 1;\n              }\n          });\n          Object.defineProperty(sentinel, 'prototype', { writable: false });\n          return sentinel.a === 1 && sentinel.prototype instanceof Object;\n      } catch (e) {\n          return false;\n      }\n  }();\n\n  // Need a workaround for getters in ES3\n  var es3 = !realDefineProp && !Object.prototype.__defineGetter__;\n\n  // We use this a lot (and need it for proto-less objects)\n  var hop = Object.prototype.hasOwnProperty;\n\n  // Naive defineProperty for compatibility\n  var defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n      if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n  };\n\n  // Array.prototype.indexOf, as good as we need it to be\n  var arrIndexOf = Array.prototype.indexOf || function (search) {\n      /*jshint validthis:true */\n      var t = this;\n      if (!t.length) return -1;\n\n      for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n          if (t[i] === search) return i;\n      }\n\n      return -1;\n  };\n\n  // Create an object with the specified prototype (2nd arg required for Record)\n  var objCreate = Object.create || function (proto, props) {\n      var obj = void 0;\n\n      function F() {}\n      F.prototype = proto;\n      obj = new F();\n\n      for (var k in props) {\n          if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n      }\n\n      return obj;\n  };\n\n  // Snapshot some (hopefully still) native built-ins\n  var arrSlice = Array.prototype.slice;\n  var arrConcat = Array.prototype.concat;\n  var arrPush = Array.prototype.push;\n  var arrJoin = Array.prototype.join;\n  var arrShift = Array.prototype.shift;\n\n  // Naive Function.prototype.bind for compatibility\n  var fnBind = Function.prototype.bind || function (thisObj) {\n      var fn = this,\n          args = arrSlice.call(arguments, 1);\n\n      // All our (presently) bound functions have either 1 or 0 arguments. By returning\n      // different function signatures, we can pass some tests in ES3 environments\n      if (fn.length === 1) {\n          return function () {\n              return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n          };\n      }\n      return function () {\n          return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n      };\n  };\n\n  // Object housing internal properties for constructors\n  var internals = objCreate(null);\n\n  // Keep internal properties internal\n  var secret = Math.random();\n\n  // Helper functions\n  // ================\n\n  /**\n   * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n   * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n   * causing issue #62.\n   */\n  function log10Floor(n) {\n      // ES6 provides the more accurate Math.log10\n      if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n\n      var x = Math.round(Math.log(n) * Math.LOG10E);\n      return x - (Number('1e' + x) > n);\n  }\n\n  /**\n   * A map that doesn't contain Object in its prototype chain\n   */\n  function Record(obj) {\n      // Copy only own properties over unless this object is already a Record instance\n      for (var k in obj) {\n          if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n      }\n  }\n  Record.prototype = objCreate(null);\n\n  /**\n   * An ordered list\n   */\n  function List() {\n      defineProperty(this, 'length', { writable: true, value: 0 });\n\n      if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n  }\n  List.prototype = objCreate(null);\n\n  /**\n   * Constructs a regular expression to restore tainted RegExp properties\n   */\n  function createRegExpRestore() {\n      if (internals.disableRegExpRestore) {\n          return function () {/* no-op */};\n      }\n\n      var regExpCache = {\n          lastMatch: RegExp.lastMatch || '',\n          leftContext: RegExp.leftContext,\n          multiline: RegExp.multiline,\n          input: RegExp.input\n      },\n          has = false;\n\n      // Create a snapshot of all the 'captured' properties\n      for (var i = 1; i <= 9; i++) {\n          has = (regExpCache['$' + i] = RegExp['$' + i]) || has;\n      }return function () {\n          // Now we've snapshotted some properties, escape the lastMatch string\n          var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n              lm = regExpCache.lastMatch.replace(esc, '\\\\$&'),\n              reg = new List();\n\n          // If any of the captured strings were non-empty, iterate over them all\n          if (has) {\n              for (var _i = 1; _i <= 9; _i++) {\n                  var m = regExpCache['$' + _i];\n\n                  // If it's empty, add an empty capturing group\n                  if (!m) lm = '()' + lm;\n\n                  // Else find the string in lm and escape & wrap it to capture it\n                  else {\n                          m = m.replace(esc, '\\\\$&');\n                          lm = lm.replace(m, '(' + m + ')');\n                      }\n\n                  // Push it to the reg and chop lm to make sure further groups come after\n                  arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n                  lm = lm.slice(lm.indexOf('(') + 1);\n              }\n          }\n\n          var exprStr = arrJoin.call(reg, '') + lm;\n\n          // Shorten the regex by replacing each part of the expression with a match\n          // for a string of that exact length.  This is safe for the type of\n          // expressions generated above, because the expression matches the whole\n          // match string, so we know each group and each segment between capturing\n          // groups can be matched by its length alone.\n          exprStr = exprStr.replace(/(\\\\\\(|\\\\\\)|[^()])+/g, function (match) {\n              return '[\\\\s\\\\S]{' + match.replace('\\\\', '').length + '}';\n          });\n\n          // Create the regular expression that will reconstruct the RegExp properties\n          var expr = new RegExp(exprStr, regExpCache.multiline ? 'gm' : 'g');\n\n          // Set the lastIndex of the generated expression to ensure that the match\n          // is found in the correct index.\n          expr.lastIndex = regExpCache.leftContext.length;\n\n          expr.exec(regExpCache.input);\n      };\n  }\n\n  /**\n   * Mimics ES5's abstract ToObject() function\n   */\n  function toObject(arg) {\n      if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n\n      if ((typeof arg === 'undefined' ? 'undefined' : babelHelpers$1['typeof'](arg)) === 'object') return arg;\n      return Object(arg);\n  }\n\n  function toNumber(arg) {\n      if (typeof arg === 'number') return arg;\n      return Number(arg);\n  }\n\n  function toInteger(arg) {\n      var number = toNumber(arg);\n      if (isNaN(number)) return 0;\n      if (number === +0 || number === -0 || number === +Infinity || number === -Infinity) return number;\n      if (number < 0) return Math.floor(Math.abs(number)) * -1;\n      return Math.floor(Math.abs(number));\n  }\n\n  function toLength(arg) {\n      var len = toInteger(arg);\n      if (len <= 0) return 0;\n      if (len === Infinity) return Math.pow(2, 53) - 1;\n      return Math.min(len, Math.pow(2, 53) - 1);\n  }\n\n  /**\n   * Returns \"internal\" properties for an object\n   */\n  function getInternalProperties(obj) {\n      if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n\n      return objCreate(null);\n  }\n\n  /**\n  * Defines regular expressions for various operations related to the BCP 47 syntax,\n  * as defined at http://tools.ietf.org/html/bcp47#section-2.1\n  */\n\n  // extlang       = 3ALPHA              ; selected ISO 639 codes\n  //                 *2(\"-\" 3ALPHA)      ; permanently reserved\n  var extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\n\n  // language      = 2*3ALPHA            ; shortest ISO 639 code\n  //                 [\"-\" extlang]       ; sometimes followed by\n  //                                     ; extended language subtags\n  //               / 4ALPHA              ; or reserved for future use\n  //               / 5*8ALPHA            ; or registered language subtag\n  var language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\n\n  // script        = 4ALPHA              ; ISO 15924 code\n  var script = '[a-z]{4}';\n\n  // region        = 2ALPHA              ; ISO 3166-1 code\n  //               / 3DIGIT              ; UN M.49 code\n  var region = '(?:[a-z]{2}|\\\\d{3})';\n\n  // variant       = 5*8alphanum         ; registered variants\n  //               / (DIGIT 3alphanum)\n  var variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\n\n  //                                     ; Single alphanumerics\n  //                                     ; \"x\" reserved for private use\n  // singleton     = DIGIT               ; 0 - 9\n  //               / %x41-57             ; A - W\n  //               / %x59-5A             ; Y - Z\n  //               / %x61-77             ; a - w\n  //               / %x79-7A             ; y - z\n  var singleton = '[0-9a-wy-z]';\n\n  // extension     = singleton 1*(\"-\" (2*8alphanum))\n  var extension = singleton + '(?:-[a-z0-9]{2,8})+';\n\n  // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n  var privateuse = 'x(?:-[a-z0-9]{1,8})+';\n\n  // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n  //               / \"i-ami\"             ; the 'langtag' production and\n  //               / \"i-bnn\"             ; would not otherwise be\n  //               / \"i-default\"         ; considered 'well-formed'\n  //               / \"i-enochian\"        ; These tags are all valid,\n  //               / \"i-hak\"             ; but most are deprecated\n  //               / \"i-klingon\"         ; in favor of more modern\n  //               / \"i-lux\"             ; subtags or subtag\n  //               / \"i-mingo\"           ; combination\n  //               / \"i-navajo\"\n  //               / \"i-pwn\"\n  //               / \"i-tao\"\n  //               / \"i-tay\"\n  //               / \"i-tsu\"\n  //               / \"sgn-BE-FR\"\n  //               / \"sgn-BE-NL\"\n  //               / \"sgn-CH-DE\"\n  var irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\n\n  // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n  //               / \"cel-gaulish\"       ; production, but their subtags\n  //               / \"no-bok\"            ; are not extended language\n  //               / \"no-nyn\"            ; or variant subtags: their meaning\n  //               / \"zh-guoyu\"          ; is defined by their registration\n  //               / \"zh-hakka\"          ; and all of these are deprecated\n  //               / \"zh-min\"            ; in favor of a more modern\n  //               / \"zh-min-nan\"        ; subtag or sequence of subtags\n  //               / \"zh-xiang\"\n  var regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\n\n  // grandfathered = irregular           ; non-redundant tags registered\n  //               / regular             ; during the RFC 3066 era\n  var grandfathered = '(?:' + irregular + '|' + regular + ')';\n\n  // langtag       = language\n  //                 [\"-\" script]\n  //                 [\"-\" region]\n  //                 *(\"-\" variant)\n  //                 *(\"-\" extension)\n  //                 [\"-\" privateuse]\n  var langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n  // Language-Tag  = langtag             ; normal language tags\n  //               / privateuse          ; private use tag\n  //               / grandfathered       ; grandfathered tags\n  var expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i');\n\n  // Match duplicate variants in a language tag\n  var expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n  // Match duplicate singletons in a language tag (except in private use)\n  var expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n  // Match all extension sequences\n  var expExtSequences = RegExp('-' + extension, 'ig');\n\n  // Default locale is the first-added locale data for us\n  var defaultLocale = void 0;\n  function setDefaultLocale(locale) {\n      defaultLocale = locale;\n  }\n\n  // IANA Subtag Registry redundant tag and subtag maps\n  var redundantTags = {\n      tags: {\n          \"art-lojban\": \"jbo\",\n          \"i-ami\": \"ami\",\n          \"i-bnn\": \"bnn\",\n          \"i-hak\": \"hak\",\n          \"i-klingon\": \"tlh\",\n          \"i-lux\": \"lb\",\n          \"i-navajo\": \"nv\",\n          \"i-pwn\": \"pwn\",\n          \"i-tao\": \"tao\",\n          \"i-tay\": \"tay\",\n          \"i-tsu\": \"tsu\",\n          \"no-bok\": \"nb\",\n          \"no-nyn\": \"nn\",\n          \"sgn-BE-FR\": \"sfb\",\n          \"sgn-BE-NL\": \"vgt\",\n          \"sgn-CH-DE\": \"sgg\",\n          \"zh-guoyu\": \"cmn\",\n          \"zh-hakka\": \"hak\",\n          \"zh-min-nan\": \"nan\",\n          \"zh-xiang\": \"hsn\",\n          \"sgn-BR\": \"bzs\",\n          \"sgn-CO\": \"csn\",\n          \"sgn-DE\": \"gsg\",\n          \"sgn-DK\": \"dsl\",\n          \"sgn-ES\": \"ssp\",\n          \"sgn-FR\": \"fsl\",\n          \"sgn-GB\": \"bfi\",\n          \"sgn-GR\": \"gss\",\n          \"sgn-IE\": \"isg\",\n          \"sgn-IT\": \"ise\",\n          \"sgn-JP\": \"jsl\",\n          \"sgn-MX\": \"mfs\",\n          \"sgn-NI\": \"ncs\",\n          \"sgn-NL\": \"dse\",\n          \"sgn-NO\": \"nsl\",\n          \"sgn-PT\": \"psr\",\n          \"sgn-SE\": \"swl\",\n          \"sgn-US\": \"ase\",\n          \"sgn-ZA\": \"sfs\",\n          \"zh-cmn\": \"cmn\",\n          \"zh-cmn-Hans\": \"cmn-Hans\",\n          \"zh-cmn-Hant\": \"cmn-Hant\",\n          \"zh-gan\": \"gan\",\n          \"zh-wuu\": \"wuu\",\n          \"zh-yue\": \"yue\"\n      },\n      subtags: {\n          BU: \"MM\",\n          DD: \"DE\",\n          FX: \"FR\",\n          TP: \"TL\",\n          YD: \"YE\",\n          ZR: \"CD\",\n          heploc: \"alalc97\",\n          'in': \"id\",\n          iw: \"he\",\n          ji: \"yi\",\n          jw: \"jv\",\n          mo: \"ro\",\n          ayx: \"nun\",\n          bjd: \"drl\",\n          ccq: \"rki\",\n          cjr: \"mom\",\n          cka: \"cmr\",\n          cmk: \"xch\",\n          drh: \"khk\",\n          drw: \"prs\",\n          gav: \"dev\",\n          hrr: \"jal\",\n          ibi: \"opa\",\n          kgh: \"kml\",\n          lcq: \"ppr\",\n          mst: \"mry\",\n          myt: \"mry\",\n          sca: \"hle\",\n          tie: \"ras\",\n          tkk: \"twm\",\n          tlw: \"weo\",\n          tnf: \"prs\",\n          ybd: \"rki\",\n          yma: \"lrr\"\n      },\n      extLang: {\n          aao: [\"aao\", \"ar\"],\n          abh: [\"abh\", \"ar\"],\n          abv: [\"abv\", \"ar\"],\n          acm: [\"acm\", \"ar\"],\n          acq: [\"acq\", \"ar\"],\n          acw: [\"acw\", \"ar\"],\n          acx: [\"acx\", \"ar\"],\n          acy: [\"acy\", \"ar\"],\n          adf: [\"adf\", \"ar\"],\n          ads: [\"ads\", \"sgn\"],\n          aeb: [\"aeb\", \"ar\"],\n          aec: [\"aec\", \"ar\"],\n          aed: [\"aed\", \"sgn\"],\n          aen: [\"aen\", \"sgn\"],\n          afb: [\"afb\", \"ar\"],\n          afg: [\"afg\", \"sgn\"],\n          ajp: [\"ajp\", \"ar\"],\n          apc: [\"apc\", \"ar\"],\n          apd: [\"apd\", \"ar\"],\n          arb: [\"arb\", \"ar\"],\n          arq: [\"arq\", \"ar\"],\n          ars: [\"ars\", \"ar\"],\n          ary: [\"ary\", \"ar\"],\n          arz: [\"arz\", \"ar\"],\n          ase: [\"ase\", \"sgn\"],\n          asf: [\"asf\", \"sgn\"],\n          asp: [\"asp\", \"sgn\"],\n          asq: [\"asq\", \"sgn\"],\n          asw: [\"asw\", \"sgn\"],\n          auz: [\"auz\", \"ar\"],\n          avl: [\"avl\", \"ar\"],\n          ayh: [\"ayh\", \"ar\"],\n          ayl: [\"ayl\", \"ar\"],\n          ayn: [\"ayn\", \"ar\"],\n          ayp: [\"ayp\", \"ar\"],\n          bbz: [\"bbz\", \"ar\"],\n          bfi: [\"bfi\", \"sgn\"],\n          bfk: [\"bfk\", \"sgn\"],\n          bjn: [\"bjn\", \"ms\"],\n          bog: [\"bog\", \"sgn\"],\n          bqn: [\"bqn\", \"sgn\"],\n          bqy: [\"bqy\", \"sgn\"],\n          btj: [\"btj\", \"ms\"],\n          bve: [\"bve\", \"ms\"],\n          bvl: [\"bvl\", \"sgn\"],\n          bvu: [\"bvu\", \"ms\"],\n          bzs: [\"bzs\", \"sgn\"],\n          cdo: [\"cdo\", \"zh\"],\n          cds: [\"cds\", \"sgn\"],\n          cjy: [\"cjy\", \"zh\"],\n          cmn: [\"cmn\", \"zh\"],\n          coa: [\"coa\", \"ms\"],\n          cpx: [\"cpx\", \"zh\"],\n          csc: [\"csc\", \"sgn\"],\n          csd: [\"csd\", \"sgn\"],\n          cse: [\"cse\", \"sgn\"],\n          csf: [\"csf\", \"sgn\"],\n          csg: [\"csg\", \"sgn\"],\n          csl: [\"csl\", \"sgn\"],\n          csn: [\"csn\", \"sgn\"],\n          csq: [\"csq\", \"sgn\"],\n          csr: [\"csr\", \"sgn\"],\n          czh: [\"czh\", \"zh\"],\n          czo: [\"czo\", \"zh\"],\n          doq: [\"doq\", \"sgn\"],\n          dse: [\"dse\", \"sgn\"],\n          dsl: [\"dsl\", \"sgn\"],\n          dup: [\"dup\", \"ms\"],\n          ecs: [\"ecs\", \"sgn\"],\n          esl: [\"esl\", \"sgn\"],\n          esn: [\"esn\", \"sgn\"],\n          eso: [\"eso\", \"sgn\"],\n          eth: [\"eth\", \"sgn\"],\n          fcs: [\"fcs\", \"sgn\"],\n          fse: [\"fse\", \"sgn\"],\n          fsl: [\"fsl\", \"sgn\"],\n          fss: [\"fss\", \"sgn\"],\n          gan: [\"gan\", \"zh\"],\n          gds: [\"gds\", \"sgn\"],\n          gom: [\"gom\", \"kok\"],\n          gse: [\"gse\", \"sgn\"],\n          gsg: [\"gsg\", \"sgn\"],\n          gsm: [\"gsm\", \"sgn\"],\n          gss: [\"gss\", \"sgn\"],\n          gus: [\"gus\", \"sgn\"],\n          hab: [\"hab\", \"sgn\"],\n          haf: [\"haf\", \"sgn\"],\n          hak: [\"hak\", \"zh\"],\n          hds: [\"hds\", \"sgn\"],\n          hji: [\"hji\", \"ms\"],\n          hks: [\"hks\", \"sgn\"],\n          hos: [\"hos\", \"sgn\"],\n          hps: [\"hps\", \"sgn\"],\n          hsh: [\"hsh\", \"sgn\"],\n          hsl: [\"hsl\", \"sgn\"],\n          hsn: [\"hsn\", \"zh\"],\n          icl: [\"icl\", \"sgn\"],\n          ils: [\"ils\", \"sgn\"],\n          inl: [\"inl\", \"sgn\"],\n          ins: [\"ins\", \"sgn\"],\n          ise: [\"ise\", \"sgn\"],\n          isg: [\"isg\", \"sgn\"],\n          isr: [\"isr\", \"sgn\"],\n          jak: [\"jak\", \"ms\"],\n          jax: [\"jax\", \"ms\"],\n          jcs: [\"jcs\", \"sgn\"],\n          jhs: [\"jhs\", \"sgn\"],\n          jls: [\"jls\", \"sgn\"],\n          jos: [\"jos\", \"sgn\"],\n          jsl: [\"jsl\", \"sgn\"],\n          jus: [\"jus\", \"sgn\"],\n          kgi: [\"kgi\", \"sgn\"],\n          knn: [\"knn\", \"kok\"],\n          kvb: [\"kvb\", \"ms\"],\n          kvk: [\"kvk\", \"sgn\"],\n          kvr: [\"kvr\", \"ms\"],\n          kxd: [\"kxd\", \"ms\"],\n          lbs: [\"lbs\", \"sgn\"],\n          lce: [\"lce\", \"ms\"],\n          lcf: [\"lcf\", \"ms\"],\n          liw: [\"liw\", \"ms\"],\n          lls: [\"lls\", \"sgn\"],\n          lsg: [\"lsg\", \"sgn\"],\n          lsl: [\"lsl\", \"sgn\"],\n          lso: [\"lso\", \"sgn\"],\n          lsp: [\"lsp\", \"sgn\"],\n          lst: [\"lst\", \"sgn\"],\n          lsy: [\"lsy\", \"sgn\"],\n          ltg: [\"ltg\", \"lv\"],\n          lvs: [\"lvs\", \"lv\"],\n          lzh: [\"lzh\", \"zh\"],\n          max: [\"max\", \"ms\"],\n          mdl: [\"mdl\", \"sgn\"],\n          meo: [\"meo\", \"ms\"],\n          mfa: [\"mfa\", \"ms\"],\n          mfb: [\"mfb\", \"ms\"],\n          mfs: [\"mfs\", \"sgn\"],\n          min: [\"min\", \"ms\"],\n          mnp: [\"mnp\", \"zh\"],\n          mqg: [\"mqg\", \"ms\"],\n          mre: [\"mre\", \"sgn\"],\n          msd: [\"msd\", \"sgn\"],\n          msi: [\"msi\", \"ms\"],\n          msr: [\"msr\", \"sgn\"],\n          mui: [\"mui\", \"ms\"],\n          mzc: [\"mzc\", \"sgn\"],\n          mzg: [\"mzg\", \"sgn\"],\n          mzy: [\"mzy\", \"sgn\"],\n          nan: [\"nan\", \"zh\"],\n          nbs: [\"nbs\", \"sgn\"],\n          ncs: [\"ncs\", \"sgn\"],\n          nsi: [\"nsi\", \"sgn\"],\n          nsl: [\"nsl\", \"sgn\"],\n          nsp: [\"nsp\", \"sgn\"],\n          nsr: [\"nsr\", \"sgn\"],\n          nzs: [\"nzs\", \"sgn\"],\n          okl: [\"okl\", \"sgn\"],\n          orn: [\"orn\", \"ms\"],\n          ors: [\"ors\", \"ms\"],\n          pel: [\"pel\", \"ms\"],\n          pga: [\"pga\", \"ar\"],\n          pks: [\"pks\", \"sgn\"],\n          prl: [\"prl\", \"sgn\"],\n          prz: [\"prz\", \"sgn\"],\n          psc: [\"psc\", \"sgn\"],\n          psd: [\"psd\", \"sgn\"],\n          pse: [\"pse\", \"ms\"],\n          psg: [\"psg\", \"sgn\"],\n          psl: [\"psl\", \"sgn\"],\n          pso: [\"pso\", \"sgn\"],\n          psp: [\"psp\", \"sgn\"],\n          psr: [\"psr\", \"sgn\"],\n          pys: [\"pys\", \"sgn\"],\n          rms: [\"rms\", \"sgn\"],\n          rsi: [\"rsi\", \"sgn\"],\n          rsl: [\"rsl\", \"sgn\"],\n          sdl: [\"sdl\", \"sgn\"],\n          sfb: [\"sfb\", \"sgn\"],\n          sfs: [\"sfs\", \"sgn\"],\n          sgg: [\"sgg\", \"sgn\"],\n          sgx: [\"sgx\", \"sgn\"],\n          shu: [\"shu\", \"ar\"],\n          slf: [\"slf\", \"sgn\"],\n          sls: [\"sls\", \"sgn\"],\n          sqk: [\"sqk\", \"sgn\"],\n          sqs: [\"sqs\", \"sgn\"],\n          ssh: [\"ssh\", \"ar\"],\n          ssp: [\"ssp\", \"sgn\"],\n          ssr: [\"ssr\", \"sgn\"],\n          svk: [\"svk\", \"sgn\"],\n          swc: [\"swc\", \"sw\"],\n          swh: [\"swh\", \"sw\"],\n          swl: [\"swl\", \"sgn\"],\n          syy: [\"syy\", \"sgn\"],\n          tmw: [\"tmw\", \"ms\"],\n          tse: [\"tse\", \"sgn\"],\n          tsm: [\"tsm\", \"sgn\"],\n          tsq: [\"tsq\", \"sgn\"],\n          tss: [\"tss\", \"sgn\"],\n          tsy: [\"tsy\", \"sgn\"],\n          tza: [\"tza\", \"sgn\"],\n          ugn: [\"ugn\", \"sgn\"],\n          ugy: [\"ugy\", \"sgn\"],\n          ukl: [\"ukl\", \"sgn\"],\n          uks: [\"uks\", \"sgn\"],\n          urk: [\"urk\", \"ms\"],\n          uzn: [\"uzn\", \"uz\"],\n          uzs: [\"uzs\", \"uz\"],\n          vgt: [\"vgt\", \"sgn\"],\n          vkk: [\"vkk\", \"ms\"],\n          vkt: [\"vkt\", \"ms\"],\n          vsi: [\"vsi\", \"sgn\"],\n          vsl: [\"vsl\", \"sgn\"],\n          vsv: [\"vsv\", \"sgn\"],\n          wuu: [\"wuu\", \"zh\"],\n          xki: [\"xki\", \"sgn\"],\n          xml: [\"xml\", \"sgn\"],\n          xmm: [\"xmm\", \"ms\"],\n          xms: [\"xms\", \"sgn\"],\n          yds: [\"yds\", \"sgn\"],\n          ysl: [\"ysl\", \"sgn\"],\n          yue: [\"yue\", \"zh\"],\n          zib: [\"zib\", \"sgn\"],\n          zlm: [\"zlm\", \"ms\"],\n          zmi: [\"zmi\", \"ms\"],\n          zsl: [\"zsl\", \"sgn\"],\n          zsm: [\"zsm\", \"ms\"]\n      }\n  };\n\n  /**\n   * Convert only a-z to uppercase as per section 6.1 of the spec\n   */\n  function toLatinUpperCase(str) {\n      var i = str.length;\n\n      while (i--) {\n          var ch = str.charAt(i);\n\n          if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n      }\n\n      return str;\n  }\n\n  /**\n   * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n   * argument (which must be a String value)\n   *\n   * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n   *   2.1, or successor,\n   * - does not include duplicate variant subtags, and\n   * - does not include duplicate singleton subtags.\n   *\n   * The abstract operation returns true if locale can be generated from the ABNF\n   * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n   * contain duplicate variant or singleton subtags (other than as a private use\n   * subtag). It returns false otherwise. Terminal value characters in the grammar are\n   * interpreted as the Unicode equivalents of the ASCII octet values given.\n   */\n  function /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n      // represents a well-formed BCP 47 language tag as specified in RFC 5646\n      if (!expBCP47Syntax.test(locale)) return false;\n\n      // does not include duplicate variant subtags, and\n      if (expVariantDupes.test(locale)) return false;\n\n      // does not include duplicate singleton subtags.\n      if (expSingletonDupes.test(locale)) return false;\n\n      return true;\n  }\n\n  /**\n   * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n   * regularized form of the locale argument (which must be a String value that is\n   * a structurally valid BCP 47 language tag as verified by the\n   * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n   * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n   * into canonical form, and to regularize the case of the subtags, but does not\n   * take the steps to bring a language tag into “extlang form” and to reorder\n   * variant subtags.\n\n   * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n   * may include canonicalization rules for the extension subtag sequences they\n   * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n   * Implementations are allowed, but not required, to apply these additional rules.\n   */\n  function /* 6.2.3 */CanonicalizeLanguageTag(locale) {\n      var match = void 0,\n          parts = void 0;\n\n      // A language tag is in 'canonical form' when the tag is well-formed\n      // according to the rules in Sections 2.1 and 2.2\n\n      // Section 2.1 says all subtags use lowercase...\n      locale = locale.toLowerCase();\n\n      // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n      // appear at the start of the tag nor occur after singletons.  Such two-letter\n      // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n      // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n      parts = locale.split('-');\n      for (var i = 1, max = parts.length; i < max; i++) {\n          // Two-letter subtags are all uppercase\n          if (parts[i].length === 2) parts[i] = parts[i].toUpperCase();\n\n          // Four-letter subtags are titlecase\n          else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n              // Is it a singleton?\n              else if (parts[i].length === 1 && parts[i] !== 'x') break;\n      }\n      locale = arrJoin.call(parts, '-');\n\n      // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n      // 1.  Extension sequences are ordered into case-insensitive ASCII order\n      //     by singleton subtag.\n      if ((match = locale.match(expExtSequences)) && match.length > 1) {\n          // The built-in sort() sorts by ASCII order, so use that\n          match.sort();\n\n          // Replace all extensions with the joined, sorted array\n          locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n      }\n\n      // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n      //     Value', if there is one.\n      if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale];\n\n      // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n      //     For extlangs, the original primary language subtag is also\n      //     replaced if there is a primary language subtag in the 'Preferred-\n      //     Value'.\n      parts = locale.split('-');\n\n      for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n          if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n              parts[_i] = redundantTags.extLang[parts[_i]][0];\n\n              // For extlang tags, the prefix needs to be removed if it is redundant\n              if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                  parts = arrSlice.call(parts, _i++);\n                  _max -= 1;\n              }\n          }\n      }\n\n      return arrJoin.call(parts, '-');\n  }\n\n  /**\n   * The DefaultLocale abstract operation returns a String value representing the\n   * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n   * host environment’s current locale.\n   */\n  function /* 6.2.4 */DefaultLocale() {\n      return defaultLocale;\n  }\n\n  // Sect 6.3 Currency Codes\n  // =======================\n\n  var expCurrencyCode = /^[A-Z]{3}$/;\n\n  /**\n   * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n   * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n   * code. The following steps are taken:\n   */\n  function /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n      // 1. Let `c` be ToString(currency)\n      var c = String(currency);\n\n      // 2. Let `normalized` be the result of mapping c to upper case as described\n      //    in 6.1.\n      var normalized = toLatinUpperCase(c);\n\n      // 3. If the string length of normalized is not 3, return false.\n      // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n      //    (U+0041 to U+005A), return false.\n      if (expCurrencyCode.test(normalized) === false) return false;\n\n      // 5. Return true\n      return true;\n  }\n\n  var expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\n  function /* 9.2.1 */CanonicalizeLocaleList(locales) {\n      // The abstract operation CanonicalizeLocaleList takes the following steps:\n\n      // 1. If locales is undefined, then a. Return a new empty List\n      if (locales === undefined) return new List();\n\n      // 2. Let seen be a new empty List.\n      var seen = new List();\n\n      // 3. If locales is a String value, then\n      //    a. Let locales be a new array created as if by the expression new\n      //    Array(locales) where Array is the standard built-in constructor with\n      //    that name and locales is the value of locales.\n      locales = typeof locales === 'string' ? [locales] : locales;\n\n      // 4. Let O be ToObject(locales).\n      var O = toObject(locales);\n\n      // 5. Let lenValue be the result of calling the [[Get]] internal method of\n      //    O with the argument \"length\".\n      // 6. Let len be ToUint32(lenValue).\n      var len = toLength(O.length);\n\n      // 7. Let k be 0.\n      var k = 0;\n\n      // 8. Repeat, while k < len\n      while (k < len) {\n          // a. Let Pk be ToString(k).\n          var Pk = String(k);\n\n          // b. Let kPresent be the result of calling the [[HasProperty]] internal\n          //    method of O with argument Pk.\n          var kPresent = Pk in O;\n\n          // c. If kPresent is true, then\n          if (kPresent) {\n              // i. Let kValue be the result of calling the [[Get]] internal\n              //     method of O with argument Pk.\n              var kValue = O[Pk];\n\n              // ii. If the type of kValue is not String or Object, then throw a\n              //     TypeError exception.\n              if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers$1[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected');\n\n              // iii. Let tag be ToString(kValue).\n              var tag = String(kValue);\n\n              // iv. If the result of calling the abstract operation\n              //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n              //     the argument, is false, then throw a RangeError exception.\n              if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n              // v. Let tag be the result of calling the abstract operation\n              //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n              //    argument.\n              tag = CanonicalizeLanguageTag(tag);\n\n              // vi. If tag is not an element of seen, then append tag as the last\n              //     element of seen.\n              if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n          }\n\n          // d. Increase k by 1.\n          k++;\n      }\n\n      // 9. Return seen.\n      return seen;\n  }\n\n  /**\n   * The BestAvailableLocale abstract operation compares the provided argument\n   * locale, which must be a String value with a structurally valid and\n   * canonicalized BCP 47 language tag, against the locales in availableLocales and\n   * returns either the longest non-empty prefix of locale that is an element of\n   * availableLocales, or undefined if there is no such element. It uses the\n   * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n   */\n  function /* 9.2.2 */BestAvailableLocale(availableLocales, locale) {\n      // 1. Let candidate be locale\n      var candidate = locale;\n\n      // 2. Repeat\n      while (candidate) {\n          // a. If availableLocales contains an element equal to candidate, then return\n          // candidate.\n          if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate;\n\n          // b. Let pos be the character index of the last occurrence of \"-\"\n          // (U+002D) within candidate. If that character does not occur, return\n          // undefined.\n          var pos = candidate.lastIndexOf('-');\n\n          if (pos < 0) return;\n\n          // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\n          //    then decrease pos by 2.\n          if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2;\n\n          // d. Let candidate be the substring of candidate from position 0, inclusive,\n          //    to position pos, exclusive.\n          candidate = candidate.substring(0, pos);\n      }\n  }\n\n  /**\n   * The LookupMatcher abstract operation compares requestedLocales, which must be\n   * a List as returned by CanonicalizeLocaleList, against the locales in\n   * availableLocales and determines the best available language to meet the\n   * request. The following steps are taken:\n   */\n  function /* 9.2.3 */LookupMatcher(availableLocales, requestedLocales) {\n      // 1. Let i be 0.\n      var i = 0;\n\n      // 2. Let len be the number of elements in requestedLocales.\n      var len = requestedLocales.length;\n\n      // 3. Let availableLocale be undefined.\n      var availableLocale = void 0;\n\n      var locale = void 0,\n          noExtensionsLocale = void 0;\n\n      // 4. Repeat while i < len and availableLocale is undefined:\n      while (i < len && !availableLocale) {\n          // a. Let locale be the element of requestedLocales at 0-origined list\n          //    position i.\n          locale = requestedLocales[i];\n\n          // b. Let noExtensionsLocale be the String value that is locale with all\n          //    Unicode locale extension sequences removed.\n          noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\n          // c. Let availableLocale be the result of calling the\n          //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n          //    arguments availableLocales and noExtensionsLocale.\n          availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n          // d. Increase i by 1.\n          i++;\n      }\n\n      // 5. Let result be a new Record.\n      var result = new Record();\n\n      // 6. If availableLocale is not undefined, then\n      if (availableLocale !== undefined) {\n          // a. Set result.[[locale]] to availableLocale.\n          result['[[locale]]'] = availableLocale;\n\n          // b. If locale and noExtensionsLocale are not the same String value, then\n          if (String(locale) !== String(noExtensionsLocale)) {\n              // i. Let extension be the String value consisting of the first\n              //    substring of locale that is a Unicode locale extension sequence.\n              var extension = locale.match(expUnicodeExSeq)[0];\n\n              // ii. Let extensionIndex be the character position of the initial\n              //     \"-\" of the first Unicode locale extension sequence within locale.\n              var extensionIndex = locale.indexOf('-u-');\n\n              // iii. Set result.[[extension]] to extension.\n              result['[[extension]]'] = extension;\n\n              // iv. Set result.[[extensionIndex]] to extensionIndex.\n              result['[[extensionIndex]]'] = extensionIndex;\n          }\n      }\n      // 7. Else\n      else\n          // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n          //    operation (defined in 6.2.4).\n          result['[[locale]]'] = DefaultLocale();\n\n      // 8. Return result\n      return result;\n  }\n\n  /**\n   * The BestFitMatcher abstract operation compares requestedLocales, which must be\n   * a List as returned by CanonicalizeLocaleList, against the locales in\n   * availableLocales and determines the best available language to meet the\n   * request. The algorithm is implementation dependent, but should produce results\n   * that a typical user of the requested locales would perceive as at least as\n   * good as those produced by the LookupMatcher abstract operation. Options\n   * specified through Unicode locale extension sequences must be ignored by the\n   * algorithm. Information about such subsequences is returned separately.\n   * The abstract operation returns a record with a [[locale]] field, whose value\n   * is the language tag of the selected locale, which must be an element of\n   * availableLocales. If the language tag of the request locale that led to the\n   * selected locale contained a Unicode locale extension sequence, then the\n   * returned record also contains an [[extension]] field whose value is the first\n   * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n   * is the index of the first Unicode locale extension sequence within the request\n   * locale language tag.\n   */\n  function /* 9.2.4 */BestFitMatcher(availableLocales, requestedLocales) {\n      return LookupMatcher(availableLocales, requestedLocales);\n  }\n\n  /**\n   * The ResolveLocale abstract operation compares a BCP 47 language priority list\n   * requestedLocales against the locales in availableLocales and determines the\n   * best available language to meet the request. availableLocales and\n   * requestedLocales must be provided as List values, options as a Record.\n   */\n  function /* 9.2.5 */ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n      if (availableLocales.length === 0) {\n          throw new ReferenceError('No locale data has been provided for this object yet.');\n      }\n\n      // The following steps are taken:\n      // 1. Let matcher be the value of options.[[localeMatcher]].\n      var matcher = options['[[localeMatcher]]'];\n\n      var r = void 0;\n\n      // 2. If matcher is \"lookup\", then\n      if (matcher === 'lookup')\n          // a. Let r be the result of calling the LookupMatcher abstract operation\n          //    (defined in 9.2.3) with arguments availableLocales and\n          //    requestedLocales.\n          r = LookupMatcher(availableLocales, requestedLocales);\n\n          // 3. Else\n      else\n          // a. Let r be the result of calling the BestFitMatcher abstract\n          //    operation (defined in 9.2.4) with arguments availableLocales and\n          //    requestedLocales.\n          r = BestFitMatcher(availableLocales, requestedLocales);\n\n      // 4. Let foundLocale be the value of r.[[locale]].\n      var foundLocale = r['[[locale]]'];\n\n      var extensionSubtags = void 0,\n          extensionSubtagsLength = void 0;\n\n      // 5. If r has an [[extension]] field, then\n      if (hop.call(r, '[[extension]]')) {\n          // a. Let extension be the value of r.[[extension]].\n          var extension = r['[[extension]]'];\n          // b. Let split be the standard built-in function object defined in ES5,\n          //    15.5.4.14.\n          var split = String.prototype.split;\n          // c. Let extensionSubtags be the result of calling the [[Call]] internal\n          //    method of split with extension as the this value and an argument\n          //    list containing the single item \"-\".\n          extensionSubtags = split.call(extension, '-');\n          // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n          //    internal method of extensionSubtags with argument \"length\".\n          extensionSubtagsLength = extensionSubtags.length;\n      }\n\n      // 6. Let result be a new Record.\n      var result = new Record();\n\n      // 7. Set result.[[dataLocale]] to foundLocale.\n      result['[[dataLocale]]'] = foundLocale;\n\n      // 8. Let supportedExtension be \"-u\".\n      var supportedExtension = '-u';\n      // 9. Let i be 0.\n      var i = 0;\n      // 10. Let len be the result of calling the [[Get]] internal method of\n      //     relevantExtensionKeys with argument \"length\".\n      var len = relevantExtensionKeys.length;\n\n      // 11 Repeat while i < len:\n      while (i < len) {\n          // a. Let key be the result of calling the [[Get]] internal method of\n          //    relevantExtensionKeys with argument ToString(i).\n          var key = relevantExtensionKeys[i];\n          // b. Let foundLocaleData be the result of calling the [[Get]] internal\n          //    method of localeData with the argument foundLocale.\n          var foundLocaleData = localeData[foundLocale];\n          // c. Let keyLocaleData be the result of calling the [[Get]] internal\n          //    method of foundLocaleData with the argument key.\n          var keyLocaleData = foundLocaleData[key];\n          // d. Let value be the result of calling the [[Get]] internal method of\n          //    keyLocaleData with argument \"0\".\n          var value = keyLocaleData['0'];\n          // e. Let supportedExtensionAddition be \"\".\n          var supportedExtensionAddition = '';\n          // f. Let indexOf be the standard built-in function object defined in\n          //    ES5, 15.4.4.14.\n          var indexOf = arrIndexOf;\n\n          // g. If extensionSubtags is not undefined, then\n          if (extensionSubtags !== undefined) {\n              // i. Let keyPos be the result of calling the [[Call]] internal\n              //    method of indexOf with extensionSubtags as the this value and\n              // an argument list containing the single item key.\n              var keyPos = indexOf.call(extensionSubtags, key);\n\n              // ii. If keyPos ≠ -1, then\n              if (keyPos !== -1) {\n                  // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                  //    result of calling the [[Get]] internal method of\n                  //    extensionSubtags with argument ToString(keyPos +1) is greater\n                  //    than 2, then\n                  if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n                      // a. Let requestedValue be the result of calling the [[Get]]\n                      //    internal method of extensionSubtags with argument\n                      //    ToString(keyPos + 1).\n                      var requestedValue = extensionSubtags[keyPos + 1];\n                      // b. Let valuePos be the result of calling the [[Call]]\n                      //    internal method of indexOf with keyLocaleData as the\n                      //    this value and an argument list containing the single\n                      //    item requestedValue.\n                      var valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                      // c. If valuePos ≠ -1, then\n                      if (valuePos !== -1) {\n                          // i. Let value be requestedValue.\n                          value = requestedValue,\n                          // ii. Let supportedExtensionAddition be the\n                          //     concatenation of \"-\", key, \"-\", and value.\n                          supportedExtensionAddition = '-' + key + '-' + value;\n                      }\n                  }\n                  // 2. Else\n                  else {\n                          // a. Let valuePos be the result of calling the [[Call]]\n                          // internal method of indexOf with keyLocaleData as the this\n                          // value and an argument list containing the single item\n                          // \"true\".\n                          var _valuePos = indexOf(keyLocaleData, 'true');\n\n                          // b. If valuePos ≠ -1, then\n                          if (_valuePos !== -1)\n                              // i. Let value be \"true\".\n                              value = 'true';\n                      }\n              }\n          }\n          // h. If options has a field [[<key>]], then\n          if (hop.call(options, '[[' + key + ']]')) {\n              // i. Let optionsValue be the value of options.[[<key>]].\n              var optionsValue = options['[[' + key + ']]'];\n\n              // ii. If the result of calling the [[Call]] internal method of indexOf\n              //     with keyLocaleData as the this value and an argument list\n              //     containing the single item optionsValue is not -1, then\n              if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                  // 1. If optionsValue is not equal to value, then\n                  if (optionsValue !== value) {\n                      // a. Let value be optionsValue.\n                      value = optionsValue;\n                      // b. Let supportedExtensionAddition be \"\".\n                      supportedExtensionAddition = '';\n                  }\n              }\n          }\n          // i. Set result.[[<key>]] to value.\n          result['[[' + key + ']]'] = value;\n\n          // j. Append supportedExtensionAddition to supportedExtension.\n          supportedExtension += supportedExtensionAddition;\n\n          // k. Increase i by 1.\n          i++;\n      }\n      // 12. If the length of supportedExtension is greater than 2, then\n      if (supportedExtension.length > 2) {\n          // a.\n          var privateIndex = foundLocale.indexOf(\"-x-\");\n          // b.\n          if (privateIndex === -1) {\n              // i.\n              foundLocale = foundLocale + supportedExtension;\n          }\n          // c.\n          else {\n                  // i.\n                  var preExtension = foundLocale.substring(0, privateIndex);\n                  // ii.\n                  var postExtension = foundLocale.substring(privateIndex);\n                  // iii.\n                  foundLocale = preExtension + supportedExtension + postExtension;\n              }\n          // d. asserting - skipping\n          // e.\n          foundLocale = CanonicalizeLanguageTag(foundLocale);\n      }\n      // 13. Set result.[[locale]] to foundLocale.\n      result['[[locale]]'] = foundLocale;\n\n      // 14. Return result.\n      return result;\n  }\n\n  /**\n   * The LookupSupportedLocales abstract operation returns the subset of the\n   * provided BCP 47 language priority list requestedLocales for which\n   * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n   * Locales appear in the same order in the returned list as in requestedLocales.\n   * The following steps are taken:\n   */\n  function /* 9.2.6 */LookupSupportedLocales(availableLocales, requestedLocales) {\n      // 1. Let len be the number of elements in requestedLocales.\n      var len = requestedLocales.length;\n      // 2. Let subset be a new empty List.\n      var subset = new List();\n      // 3. Let k be 0.\n      var k = 0;\n\n      // 4. Repeat while k < len\n      while (k < len) {\n          // a. Let locale be the element of requestedLocales at 0-origined list\n          //    position k.\n          var locale = requestedLocales[k];\n          // b. Let noExtensionsLocale be the String value that is locale with all\n          //    Unicode locale extension sequences removed.\n          var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n          // c. Let availableLocale be the result of calling the\n          //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n          //    arguments availableLocales and noExtensionsLocale.\n          var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n          // d. If availableLocale is not undefined, then append locale to the end of\n          //    subset.\n          if (availableLocale !== undefined) arrPush.call(subset, locale);\n\n          // e. Increment k by 1.\n          k++;\n      }\n\n      // 5. Let subsetArray be a new Array object whose elements are the same\n      //    values in the same order as the elements of subset.\n      var subsetArray = arrSlice.call(subset);\n\n      // 6. Return subsetArray.\n      return subsetArray;\n  }\n\n  /**\n   * The BestFitSupportedLocales abstract operation returns the subset of the\n   * provided BCP 47 language priority list requestedLocales for which\n   * availableLocales has a matching locale when using the Best Fit Matcher\n   * algorithm. Locales appear in the same order in the returned list as in\n   * requestedLocales. The steps taken are implementation dependent.\n   */\n  function /*9.2.7 */BestFitSupportedLocales(availableLocales, requestedLocales) {\n      // ###TODO: implement this function as described by the specification###\n      return LookupSupportedLocales(availableLocales, requestedLocales);\n  }\n\n  /**\n   * The SupportedLocales abstract operation returns the subset of the provided BCP\n   * 47 language priority list requestedLocales for which availableLocales has a\n   * matching locale. Two algorithms are available to match the locales: the Lookup\n   * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n   * best-fit algorithm. Locales appear in the same order in the returned list as\n   * in requestedLocales. The following steps are taken:\n   */\n  function /*9.2.8 */SupportedLocales(availableLocales, requestedLocales, options) {\n      var matcher = void 0,\n          subset = void 0;\n\n      // 1. If options is not undefined, then\n      if (options !== undefined) {\n          // a. Let options be ToObject(options).\n          options = new Record(toObject(options));\n          // b. Let matcher be the result of calling the [[Get]] internal method of\n          //    options with argument \"localeMatcher\".\n          matcher = options.localeMatcher;\n\n          // c. If matcher is not undefined, then\n          if (matcher !== undefined) {\n              // i. Let matcher be ToString(matcher).\n              matcher = String(matcher);\n\n              // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n              //     exception.\n              if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n          }\n      }\n      // 2. If matcher is undefined or \"best fit\", then\n      if (matcher === undefined || matcher === 'best fit')\n          // a. Let subset be the result of calling the BestFitSupportedLocales\n          //    abstract operation (defined in 9.2.7) with arguments\n          //    availableLocales and requestedLocales.\n          subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n          // 3. Else\n      else\n          // a. Let subset be the result of calling the LookupSupportedLocales\n          //    abstract operation (defined in 9.2.6) with arguments\n          //    availableLocales and requestedLocales.\n          subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n      // 4. For each named own property name P of subset,\n      for (var P in subset) {\n          if (!hop.call(subset, P)) continue;\n\n          // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n          //    method of subset with P.\n          // b. Set desc.[[Writable]] to false.\n          // c. Set desc.[[Configurable]] to false.\n          // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n          //    and true as arguments.\n          defineProperty(subset, P, {\n              writable: false, configurable: false, value: subset[P]\n          });\n      }\n      // \"Freeze\" the array so no new elements can be added\n      defineProperty(subset, 'length', { writable: false });\n\n      // 5. Return subset\n      return subset;\n  }\n\n  /**\n   * The GetOption abstract operation extracts the value of the property named\n   * property from the provided options object, converts it to the required type,\n   * checks whether it is one of a List of allowed values, and fills in a fallback\n   * value if necessary.\n   */\n  function /*9.2.9 */GetOption(options, property, type, values, fallback) {\n      // 1. Let value be the result of calling the [[Get]] internal method of\n      //    options with argument property.\n      var value = options[property];\n\n      // 2. If value is not undefined, then\n      if (value !== undefined) {\n          // a. Assert: type is \"boolean\" or \"string\".\n          // b. If type is \"boolean\", then let value be ToBoolean(value).\n          // c. If type is \"string\", then let value be ToString(value).\n          value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value;\n\n          // d. If values is not undefined, then\n          if (values !== undefined) {\n              // i. If values does not contain an element equal to value, then throw a\n              //    RangeError exception.\n              if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n          }\n\n          // e. Return value.\n          return value;\n      }\n      // Else return fallback.\n      return fallback;\n  }\n\n  /**\n   * The GetNumberOption abstract operation extracts a property value from the\n   * provided options object, converts it to a Number value, checks whether it is\n   * in the allowed range, and fills in a fallback value if necessary.\n   */\n  function /* 9.2.10 */GetNumberOption(options, property, minimum, maximum, fallback) {\n      // 1. Let value be the result of calling the [[Get]] internal method of\n      //    options with argument property.\n      var value = options[property];\n\n      // 2. If value is not undefined, then\n      if (value !== undefined) {\n          // a. Let value be ToNumber(value).\n          value = Number(value);\n\n          // b. If value is NaN or less than minimum or greater than maximum, throw a\n          //    RangeError exception.\n          if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range');\n\n          // c. Return floor(value).\n          return Math.floor(value);\n      }\n      // 3. Else return fallback.\n      return fallback;\n  }\n\n  // 8 The Intl Object\n  var Intl$1 = {};\n\n  // 8.2 Function Properties of the Intl Object\n\n  // 8.2.1\n  // @spec[tc39/ecma402/master/spec/intl.html]\n  // @clause[sec-intl.getcanonicallocales]\n  function getCanonicalLocales(locales) {\n      // 1. Let ll be ? CanonicalizeLocaleList(locales).\n      var ll = CanonicalizeLocaleList(locales);\n      // 2. Return CreateArrayFromList(ll).\n      {\n          var result = [];\n\n          var len = ll.length;\n          var k = 0;\n\n          while (k < len) {\n              result[k] = ll[k];\n              k++;\n          }\n          return result;\n      }\n  }\n\n  Object.defineProperty(Intl$1, 'getCanonicalLocales', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: getCanonicalLocales\n  });\n\n  // Currency minor units output from get-4217 grunt task, formatted\n  var currencyMinorUnits = {\n      BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n      XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n      OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n  };\n\n  // Define the NumberFormat constructor internally so it cannot be tainted\n  function NumberFormatConstructor() {\n      var locales = arguments[0];\n      var options = arguments[1];\n\n      if (!this || this === Intl$1) {\n          return new Intl$1.NumberFormat(locales, options);\n      }\n\n      return InitializeNumberFormat(toObject(this), locales, options);\n  }\n\n  defineProperty(Intl$1, 'NumberFormat', {\n      configurable: true,\n      writable: true,\n      value: NumberFormatConstructor\n  });\n\n  // Must explicitly set prototypes as unwritable\n  defineProperty(Intl$1.NumberFormat, 'prototype', {\n      writable: false\n  });\n\n  /**\n   * The abstract operation InitializeNumberFormat accepts the arguments\n   * numberFormat (which must be an object), locales, and options. It initializes\n   * numberFormat as a NumberFormat object.\n   */\n  function /*11.1.1.1 */InitializeNumberFormat(numberFormat, locales, options) {\n      // This will be a internal properties object if we're not already initialized\n      var internal = getInternalProperties(numberFormat);\n\n      // Create an object whose props can be used to restore the values of RegExp props\n      var regexpRestore = createRegExpRestore();\n\n      // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n      // value true, throw a TypeError exception.\n      if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n      // Need this to access the `internal` object\n      defineProperty(numberFormat, '__getInternalProperties', {\n          value: function value() {\n              // NOTE: Non-standard, for internal use only\n              if (arguments[0] === secret) return internal;\n          }\n      });\n\n      // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n      internal['[[initializedIntlObject]]'] = true;\n\n      // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n      //    abstract operation (defined in 9.2.1) with argument locales.\n      var requestedLocales = CanonicalizeLocaleList(locales);\n\n      // 4. If options is undefined, then\n      if (options === undefined)\n          // a. Let options be the result of creating a new object as if by the\n          // expression new Object() where Object is the standard built-in constructor\n          // with that name.\n          options = {};\n\n          // 5. Else\n      else\n          // a. Let options be ToObject(options).\n          options = toObject(options);\n\n      // 6. Let opt be a new Record.\n      var opt = new Record(),\n\n\n      // 7. Let matcher be the result of calling the GetOption abstract operation\n      //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n      //    a List containing the two String values \"lookup\" and \"best fit\", and\n      //    \"best fit\".\n      matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n      // 8. Set opt.[[localeMatcher]] to matcher.\n      opt['[[localeMatcher]]'] = matcher;\n\n      // 9. Let NumberFormat be the standard built-in object that is the initial value\n      //    of Intl.NumberFormat.\n      // 10. Let localeData be the value of the [[localeData]] internal property of\n      //     NumberFormat.\n      var localeData = internals.NumberFormat['[[localeData]]'];\n\n      // 11. Let r be the result of calling the ResolveLocale abstract operation\n      //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n      //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n      //     internal property of NumberFormat, and localeData.\n      var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData);\n\n      // 12. Set the [[locale]] internal property of numberFormat to the value of\n      //     r.[[locale]].\n      internal['[[locale]]'] = r['[[locale]]'];\n\n      // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n      //     of r.[[nu]].\n      internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n      // The specification doesn't tell us to do this, but it's helpful later on\n      internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n      // 14. Let dataLocale be the value of r.[[dataLocale]].\n      var dataLocale = r['[[dataLocale]]'];\n\n      // 15. Let s be the result of calling the GetOption abstract operation with the\n      //     arguments options, \"style\", \"string\", a List containing the three String\n      //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n      var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n      // 16. Set the [[style]] internal property of numberFormat to s.\n      internal['[[style]]'] = s;\n\n      // 17. Let c be the result of calling the GetOption abstract operation with the\n      //     arguments options, \"currency\", \"string\", undefined, and undefined.\n      var c = GetOption(options, 'currency', 'string');\n\n      // 18. If c is not undefined and the result of calling the\n      //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n      //     argument c is false, then throw a RangeError exception.\n      if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n      // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n      if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n\n      var cDigits = void 0;\n\n      // 20. If s is \"currency\", then\n      if (s === 'currency') {\n          // a. Let c be the result of converting c to upper case as specified in 6.1.\n          c = c.toUpperCase();\n\n          // b. Set the [[currency]] internal property of numberFormat to c.\n          internal['[[currency]]'] = c;\n\n          // c. Let cDigits be the result of calling the CurrencyDigits abstract\n          //    operation (defined below) with argument c.\n          cDigits = CurrencyDigits(c);\n      }\n\n      // 21. Let cd be the result of calling the GetOption abstract operation with the\n      //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n      //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n      var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n      // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n      //     numberFormat to cd.\n      if (s === 'currency') internal['[[currencyDisplay]]'] = cd;\n\n      // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n      //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n      //     and 1.\n      var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n      // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n      internal['[[minimumIntegerDigits]]'] = mnid;\n\n      // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n      //     be 0.\n      var mnfdDefault = s === 'currency' ? cDigits : 0;\n\n      // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n      //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n      var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n      // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n      internal['[[minimumFractionDigits]]'] = mnfd;\n\n      // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n      //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n      //     be max(mnfd, 3).\n      var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3);\n\n      // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n      //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n      var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n      // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n      internal['[[maximumFractionDigits]]'] = mxfd;\n\n      // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n      //     with argument \"minimumSignificantDigits\".\n      var mnsd = options.minimumSignificantDigits;\n\n      // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n      //     with argument \"maximumSignificantDigits\".\n      var mxsd = options.maximumSignificantDigits;\n\n      // 33. If mnsd is not undefined or mxsd is not undefined, then:\n      if (mnsd !== undefined || mxsd !== undefined) {\n          // a. Let mnsd be the result of calling the GetNumberOption abstract\n          //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n          //    and 1.\n          mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n          // b. Let mxsd be the result of calling the GetNumberOption abstract\n          //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n          //     21, and 21.\n          mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n          // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n          //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n          //    numberFormat to mxsd.\n          internal['[[minimumSignificantDigits]]'] = mnsd;\n          internal['[[maximumSignificantDigits]]'] = mxsd;\n      }\n      // 34. Let g be the result of calling the GetOption abstract operation with the\n      //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n      var g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n      // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n      internal['[[useGrouping]]'] = g;\n\n      // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n      //     localeData with argument dataLocale.\n      var dataLocaleData = localeData[dataLocale];\n\n      // 37. Let patterns be the result of calling the [[Get]] internal method of\n      //     dataLocaleData with argument \"patterns\".\n      var patterns = dataLocaleData.patterns;\n\n      // 38. Assert: patterns is an object (see 11.2.3)\n\n      // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n      //     patterns with argument s.\n      var stylePatterns = patterns[s];\n\n      // 40. Set the [[positivePattern]] internal property of numberFormat to the\n      //     result of calling the [[Get]] internal method of stylePatterns with the\n      //     argument \"positivePattern\".\n      internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n      // 41. Set the [[negativePattern]] internal property of numberFormat to the\n      //     result of calling the [[Get]] internal method of stylePatterns with the\n      //     argument \"negativePattern\".\n      internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n      // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n      internal['[[boundFormat]]'] = undefined;\n\n      // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n      //     true.\n      internal['[[initializedNumberFormat]]'] = true;\n\n      // In ES3, we need to pre-bind the format() function\n      if (es3) numberFormat.format = GetFormatNumber.call(numberFormat);\n\n      // Restore the RegExp properties\n      regexpRestore();\n\n      // Return the newly initialised object\n      return numberFormat;\n  }\n\n  function CurrencyDigits(currency) {\n      // When the CurrencyDigits abstract operation is called with an argument currency\n      // (which must be an upper case String value), the following steps are taken:\n\n      // 1. If the ISO 4217 currency and funds code list contains currency as an\n      // alphabetic code, then return the minor unit value corresponding to the\n      // currency from the list; else return 2.\n      return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n  }\n\n  /* 11.2.3 */internals.NumberFormat = {\n      '[[availableLocales]]': [],\n      '[[relevantExtensionKeys]]': ['nu'],\n      '[[localeData]]': {}\n  };\n\n  /**\n   * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n   * following steps are taken:\n   */\n  /* 11.2.2 */\n  defineProperty(Intl$1.NumberFormat, 'supportedLocalesOf', {\n      configurable: true,\n      writable: true,\n      value: fnBind.call(function (locales) {\n          // Bound functions only have the `this` value altered if being used as a constructor,\n          // this lets us imitate a native function that has no constructor\n          if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n          // Create an object whose props can be used to restore the values of RegExp props\n          var regexpRestore = createRegExpRestore(),\n\n\n          // 1. If options is not provided, then let options be undefined.\n          options = arguments[1],\n\n\n          // 2. Let availableLocales be the value of the [[availableLocales]] internal\n          //    property of the standard built-in object that is the initial value of\n          //    Intl.NumberFormat.\n\n          availableLocales = this['[[availableLocales]]'],\n\n\n          // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n          //    abstract operation (defined in 9.2.1) with argument locales.\n          requestedLocales = CanonicalizeLocaleList(locales);\n\n          // Restore the RegExp properties\n          regexpRestore();\n\n          // 4. Return the result of calling the SupportedLocales abstract operation\n          //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n          //    and options.\n          return SupportedLocales(availableLocales, requestedLocales, options);\n      }, internals.NumberFormat)\n  });\n\n  /**\n   * This named accessor property returns a function that formats a number\n   * according to the effective locale and the formatting options of this\n   * NumberFormat object.\n   */\n  /* 11.3.2 */defineProperty(Intl$1.NumberFormat.prototype, 'format', {\n      configurable: true,\n      get: GetFormatNumber\n  });\n\n  function GetFormatNumber() {\n      var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n      // Satisfy test 11.3_b\n      if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n      // The value of the [[Get]] attribute is a function that takes the following\n      // steps:\n\n      // 1. If the [[boundFormat]] internal property of this NumberFormat object\n      //    is undefined, then:\n      if (internal['[[boundFormat]]'] === undefined) {\n          // a. Let F be a Function object, with internal properties set as\n          //    specified for built-in functions in ES5, 15, or successor, and the\n          //    length property set to 1, that takes the argument value and\n          //    performs the following steps:\n          var F = function F(value) {\n              // i. If value is not provided, then let value be undefined.\n              // ii. Let x be ToNumber(value).\n              // iii. Return the result of calling the FormatNumber abstract\n              //      operation (defined below) with arguments this and x.\n              return FormatNumber(this, /* x = */Number(value));\n          };\n\n          // b. Let bind be the standard built-in function object defined in ES5,\n          //    15.3.4.5.\n          // c. Let bf be the result of calling the [[Call]] internal method of\n          //    bind with F as the this value and an argument list containing\n          //    the single item this.\n          var bf = fnBind.call(F, this);\n\n          // d. Set the [[boundFormat]] internal property of this NumberFormat\n          //    object to bf.\n          internal['[[boundFormat]]'] = bf;\n      }\n      // Return the value of the [[boundFormat]] internal property of this\n      // NumberFormat object.\n      return internal['[[boundFormat]]'];\n  }\n\n  function formatToParts() {\n      var value = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n      var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n      if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n\n      var x = Number(value);\n      return FormatNumberToParts(this, x);\n  }\n\n  Object.defineProperty(Intl$1.NumberFormat.prototype, 'formatToParts', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: formatToParts\n  });\n\n  /*\n   * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n   * @clause[sec-formatnumbertoparts]\n   */\n  function FormatNumberToParts(numberFormat, x) {\n      // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n      var parts = PartitionNumberPattern(numberFormat, x);\n      // 2. Let result be ArrayCreate(0).\n      var result = [];\n      // 3. Let n be 0.\n      var n = 0;\n      // 4. For each part in parts, do:\n      for (var i = 0; parts.length > i; i++) {\n          var part = parts[i];\n          // a. Let O be ObjectCreate(%ObjectPrototype%).\n          var O = {};\n          // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n          O.type = part['[[type]]'];\n          // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n          O.value = part['[[value]]'];\n          // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n          result[n] = O;\n          // a. Increment n by 1.\n          n += 1;\n      }\n      // 5. Return result.\n      return result;\n  }\n\n  /*\n   * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n   * @clause[sec-partitionnumberpattern]\n   */\n  function PartitionNumberPattern(numberFormat, x) {\n\n      var internal = getInternalProperties(numberFormat),\n          locale = internal['[[dataLocale]]'],\n          nums = internal['[[numberingSystem]]'],\n          data = internals.NumberFormat['[[localeData]]'][locale],\n          ild = data.symbols[nums] || data.symbols.latn,\n          pattern = void 0;\n\n      // 1. If x is not NaN and x < 0, then:\n      if (!isNaN(x) && x < 0) {\n          // a. Let x be -x.\n          x = -x;\n          // a. Let pattern be the value of numberFormat.[[negativePattern]].\n          pattern = internal['[[negativePattern]]'];\n      }\n      // 2. Else,\n      else {\n              // a. Let pattern be the value of numberFormat.[[positivePattern]].\n              pattern = internal['[[positivePattern]]'];\n          }\n      // 3. Let result be a new empty List.\n      var result = new List();\n      // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n      var beginIndex = pattern.indexOf('{', 0);\n      // 5. Let endIndex be 0.\n      var endIndex = 0;\n      // 6. Let nextIndex be 0.\n      var nextIndex = 0;\n      // 7. Let length be the number of code units in pattern.\n      var length = pattern.length;\n      // 8. Repeat while beginIndex is an integer index into pattern:\n      while (beginIndex > -1 && beginIndex < length) {\n          // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n          endIndex = pattern.indexOf('}', beginIndex);\n          // a. If endIndex = -1, throw new Error exception.\n          if (endIndex === -1) throw new Error();\n          // a. If beginIndex is greater than nextIndex, then:\n          if (beginIndex > nextIndex) {\n              // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n              var literal = pattern.substring(nextIndex, beginIndex);\n              // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n              arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\n          }\n          // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n          var p = pattern.substring(beginIndex + 1, endIndex);\n          // a. If p is equal \"number\", then:\n          if (p === \"number\") {\n              // i. If x is NaN,\n              if (isNaN(x)) {\n                  // 1. Let n be an ILD String value indicating the NaN value.\n                  var n = ild.nan;\n                  // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n                  arrPush.call(result, { '[[type]]': 'nan', '[[value]]': n });\n              }\n              // ii. Else if isFinite(x) is false,\n              else if (!isFinite(x)) {\n                      // 1. Let n be an ILD String value indicating infinity.\n                      var _n = ild.infinity;\n                      // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n                      arrPush.call(result, { '[[type]]': 'infinity', '[[value]]': _n });\n                  }\n                  // iii. Else,\n                  else {\n                          // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100 × x.\n                          if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\n                          var _n2 = void 0;\n                          // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n                          if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n                              // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n                              _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n                          }\n                          // 3. Else,\n                          else {\n                                  // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n                                  _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n                              }\n                          // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n                          if (numSys[nums]) {\n                              (function () {\n                                  // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n                                  var digits = numSys[nums];\n                                  // a. Replace each digit in n with the value of digits[digit].\n                                  _n2 = String(_n2).replace(/\\d/g, function (digit) {\n                                      return digits[digit];\n                                  });\n                              })();\n                          }\n                          // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n                          else _n2 = String(_n2); // ###TODO###\n\n                          var integer = void 0;\n                          var fraction = void 0;\n                          // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n                          var decimalSepIndex = _n2.indexOf('.', 0);\n                          // 7. If decimalSepIndex > 0, then:\n                          if (decimalSepIndex > 0) {\n                              // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n                              integer = _n2.substring(0, decimalSepIndex);\n                              // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n                              fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n                          }\n                          // 8. Else:\n                          else {\n                                  // a. Let integer be n.\n                                  integer = _n2;\n                                  // a. Let fraction be undefined.\n                                  fraction = undefined;\n                              }\n                          // 9. If the value of the numberFormat.[[useGrouping]] is true,\n                          if (internal['[[useGrouping]]'] === true) {\n                              // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n                              var groupSepSymbol = ild.group;\n                              // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n                              var groups = [];\n                              // ----> implementation:\n                              // Primary group represents the group closest to the decimal\n                              var pgSize = data.patterns.primaryGroupSize || 3;\n                              // Secondary group is every other group\n                              var sgSize = data.patterns.secondaryGroupSize || pgSize;\n                              // Group only if necessary\n                              if (integer.length > pgSize) {\n                                  // Index of the primary grouping separator\n                                  var end = integer.length - pgSize;\n                                  // Starting index for our loop\n                                  var idx = end % sgSize;\n                                  var start = integer.slice(0, idx);\n                                  if (start.length) arrPush.call(groups, start);\n                                  // Loop to separate into secondary grouping digits\n                                  while (idx < end) {\n                                      arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                                      idx += sgSize;\n                                  }\n                                  // Add the primary grouping digits\n                                  arrPush.call(groups, integer.slice(end));\n                              } else {\n                                  arrPush.call(groups, integer);\n                              }\n                              // a. Assert: The number of elements in groups List is greater than 0.\n                              if (groups.length === 0) throw new Error();\n                              // a. Repeat, while groups List is not empty:\n                              while (groups.length) {\n                                  // i. Remove the first element from groups and let integerGroup be the value of that element.\n                                  var integerGroup = arrShift.call(groups);\n                                  // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n                                  arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integerGroup });\n                                  // iii. If groups List is not empty, then:\n                                  if (groups.length) {\n                                      // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n                                      arrPush.call(result, { '[[type]]': 'group', '[[value]]': groupSepSymbol });\n                                  }\n                              }\n                          }\n                          // 10. Else,\n                          else {\n                                  // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n                                  arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integer });\n                              }\n                          // 11. If fraction is not undefined, then:\n                          if (fraction !== undefined) {\n                              // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n                              var decimalSepSymbol = ild.decimal;\n                              // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n                              arrPush.call(result, { '[[type]]': 'decimal', '[[value]]': decimalSepSymbol });\n                              // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n                              arrPush.call(result, { '[[type]]': 'fraction', '[[value]]': fraction });\n                          }\n                      }\n          }\n          // a. Else if p is equal \"plusSign\", then:\n          else if (p === \"plusSign\") {\n                  // i. Let plusSignSymbol be the ILND String representing the plus sign.\n                  var plusSignSymbol = ild.plusSign;\n                  // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n                  arrPush.call(result, { '[[type]]': 'plusSign', '[[value]]': plusSignSymbol });\n              }\n              // a. Else if p is equal \"minusSign\", then:\n              else if (p === \"minusSign\") {\n                      // i. Let minusSignSymbol be the ILND String representing the minus sign.\n                      var minusSignSymbol = ild.minusSign;\n                      // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n                      arrPush.call(result, { '[[type]]': 'minusSign', '[[value]]': minusSignSymbol });\n                  }\n                  // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n                  else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n                          // i. Let percentSignSymbol be the ILND String representing the percent sign.\n                          var percentSignSymbol = ild.percentSign;\n                          // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n                          arrPush.call(result, { '[[type]]': 'literal', '[[value]]': percentSignSymbol });\n                      }\n                      // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n                      else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n                              // i. Let currency be the value of numberFormat.[[currency]].\n                              var currency = internal['[[currency]]'];\n\n                              var cd = void 0;\n\n                              // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n                              if (internal['[[currencyDisplay]]'] === \"code\") {\n                                  // 1. Let cd be currency.\n                                  cd = currency;\n                              }\n                              // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n                              else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n                                      // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n                                      cd = data.currencies[currency] || currency;\n                                  }\n                                  // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n                                  else if (internal['[[currencyDisplay]]'] === \"name\") {\n                                          // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n                                          cd = currency;\n                                      }\n                              // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n                              arrPush.call(result, { '[[type]]': 'currency', '[[value]]': cd });\n                          }\n                          // a. Else,\n                          else {\n                                  // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n                                  var _literal = pattern.substring(beginIndex, endIndex);\n                                  // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n                                  arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal });\n                              }\n          // a. Set nextIndex to endIndex + 1.\n          nextIndex = endIndex + 1;\n          // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n          beginIndex = pattern.indexOf('{', nextIndex);\n      }\n      // 9. If nextIndex is less than length, then:\n      if (nextIndex < length) {\n          // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n          var _literal2 = pattern.substring(nextIndex, length);\n          // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n          arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal2 });\n      }\n      // 10. Return result.\n      return result;\n  }\n\n  /*\n   * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n   * @clause[sec-formatnumber]\n   */\n  function FormatNumber(numberFormat, x) {\n      // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n      var parts = PartitionNumberPattern(numberFormat, x);\n      // 2. Let result be an empty String.\n      var result = '';\n      // 3. For each part in parts, do:\n      for (var i = 0; parts.length > i; i++) {\n          var part = parts[i];\n          // a. Set result to a String value produced by concatenating result and part.[[value]].\n          result += part['[[value]]'];\n      }\n      // 4. Return result.\n      return result;\n  }\n\n  /**\n   * When the ToRawPrecision abstract operation is called with arguments x (which\n   * must be a finite non-negative number), minPrecision, and maxPrecision (both\n   * must be integers between 1 and 21) the following steps are taken:\n   */\n  function ToRawPrecision(x, minPrecision, maxPrecision) {\n      // 1. Let p be maxPrecision.\n      var p = maxPrecision;\n\n      var m = void 0,\n          e = void 0;\n\n      // 2. If x = 0, then\n      if (x === 0) {\n          // a. Let m be the String consisting of p occurrences of the character \"0\".\n          m = arrJoin.call(Array(p + 1), '0');\n          // b. Let e be 0.\n          e = 0;\n      }\n      // 3. Else\n      else {\n              // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\n              //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\n              //    possible. If there are two such sets of e and n, pick the e and n for\n              //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\n              e = log10Floor(Math.abs(x));\n\n              // Easier to get to m from here\n              var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10));\n\n              // b. Let m be the String consisting of the digits of the decimal\n              //    representation of n (in order, with no leading zeroes)\n              m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n          }\n\n      // 4. If e ≥ p, then\n      if (e >= p)\n          // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n          return m + arrJoin.call(Array(e - p + 1 + 1), '0');\n\n          // 5. If e = p-1, then\n      else if (e === p - 1)\n              // a. Return m.\n              return m;\n\n              // 6. If e ≥ 0, then\n          else if (e >= 0)\n                  // a. Let m be the concatenation of the first e+1 characters of m, the character\n                  //    \".\", and the remaining p–(e+1) characters of m.\n                  m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n                  // 7. If e < 0, then\n              else if (e < 0)\n                      // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\n                      //    character \"0\", and the string m.\n                      m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m;\n\n      // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n      if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n          // a. Let cut be maxPrecision – minPrecision.\n          var cut = maxPrecision - minPrecision;\n\n          // b. Repeat while cut > 0 and the last character of m is \"0\":\n          while (cut > 0 && m.charAt(m.length - 1) === '0') {\n              //  i. Remove the last character from m.\n              m = m.slice(0, -1);\n\n              //  ii. Decrease cut by 1.\n              cut--;\n          }\n\n          // c. If the last character of m is \".\", then\n          if (m.charAt(m.length - 1) === '.')\n              //    i. Remove the last character from m.\n              m = m.slice(0, -1);\n      }\n      // 9. Return m.\n      return m;\n  }\n\n  /**\n   * @spec[tc39/ecma402/master/spec/numberformat.html]\n   * @clause[sec-torawfixed]\n   * When the ToRawFixed abstract operation is called with arguments x (which must\n   * be a finite non-negative number), minInteger (which must be an integer between\n   * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n   * 20) the following steps are taken:\n   */\n  function ToRawFixed(x, minInteger, minFraction, maxFraction) {\n      // 1. Let f be maxFraction.\n      var f = maxFraction;\n      // 2. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n.\n      var n = Math.pow(10, f) * x; // diverging...\n      // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n      var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\n      {\n          // this diversion is needed to take into consideration big numbers, e.g.:\n          // 1.2344501e+37 -> 12344501000000000000000000000000000000\n          var idx = void 0;\n          var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n          if (exp) {\n              m = m.slice(0, idx).replace('.', '');\n              m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n          }\n      }\n\n      var int = void 0;\n      // 4. If f ≠ 0, then\n      if (f !== 0) {\n          // a. Let k be the number of characters in m.\n          var k = m.length;\n          // a. If k ≤ f, then\n          if (k <= f) {\n              // i. Let z be the String consisting of f+1–k occurrences of the character \"0\".\n              var z = arrJoin.call(Array(f + 1 - k + 1), '0');\n              // ii. Let m be the concatenation of Strings z and m.\n              m = z + m;\n              // iii. Let k be f+1.\n              k = f + 1;\n          }\n          // a. Let a be the first k–f characters of m, and let b be the remaining f characters of m.\n          var a = m.substring(0, k - f),\n              b = m.substring(k - f, m.length);\n          // a. Let m be the concatenation of the three Strings a, \".\", and b.\n          m = a + \".\" + b;\n          // a. Let int be the number of characters in a.\n          int = a.length;\n      }\n      // 5. Else, let int be the number of characters in m.\n      else int = m.length;\n      // 6. Let cut be maxFraction – minFraction.\n      var cut = maxFraction - minFraction;\n      // 7. Repeat while cut > 0 and the last character of m is \"0\":\n      while (cut > 0 && m.slice(-1) === \"0\") {\n          // a. Remove the last character from m.\n          m = m.slice(0, -1);\n          // a. Decrease cut by 1.\n          cut--;\n      }\n      // 8. If the last character of m is \".\", then\n      if (m.slice(-1) === \".\") {\n          // a. Remove the last character from m.\n          m = m.slice(0, -1);\n      }\n      // 9. If int < minInteger, then\n      if (int < minInteger) {\n          // a. Let z be the String consisting of minInteger–int occurrences of the character \"0\".\n          var _z = arrJoin.call(Array(minInteger - int + 1), '0');\n          // a. Let m be the concatenation of Strings z and m.\n          m = _z + m;\n      }\n      // 10. Return m.\n      return m;\n  }\n\n  // Sect 11.3.2 Table 2, Numbering systems\n  // ======================================\n  var numSys = {\n      arab: [\"٠\", \"١\", \"٢\", \"٣\", \"٤\", \"٥\", \"٦\", \"٧\", \"٨\", \"٩\"],\n      arabext: [\"۰\", \"۱\", \"۲\", \"۳\", \"۴\", \"۵\", \"۶\", \"۷\", \"۸\", \"۹\"],\n      bali: [\"᭐\", \"᭑\", \"᭒\", \"᭓\", \"᭔\", \"᭕\", \"᭖\", \"᭗\", \"᭘\", \"᭙\"],\n      beng: [\"০\", \"১\", \"২\", \"৩\", \"৪\", \"৫\", \"৬\", \"৭\", \"৮\", \"৯\"],\n      deva: [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\"],\n      fullwide: [\"０\", \"１\", \"２\", \"３\", \"４\", \"５\", \"６\", \"７\", \"８\", \"９\"],\n      gujr: [\"૦\", \"૧\", \"૨\", \"૩\", \"૪\", \"૫\", \"૬\", \"૭\", \"૮\", \"૯\"],\n      guru: [\"੦\", \"੧\", \"੨\", \"੩\", \"੪\", \"੫\", \"੬\", \"੭\", \"੮\", \"੯\"],\n      hanidec: [\"〇\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"],\n      khmr: [\"០\", \"១\", \"២\", \"៣\", \"៤\", \"៥\", \"៦\", \"៧\", \"៨\", \"៩\"],\n      knda: [\"೦\", \"೧\", \"೨\", \"೩\", \"೪\", \"೫\", \"೬\", \"೭\", \"೮\", \"೯\"],\n      laoo: [\"໐\", \"໑\", \"໒\", \"໓\", \"໔\", \"໕\", \"໖\", \"໗\", \"໘\", \"໙\"],\n      latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n      limb: [\"᥆\", \"᥇\", \"᥈\", \"᥉\", \"᥊\", \"᥋\", \"᥌\", \"᥍\", \"᥎\", \"᥏\"],\n      mlym: [\"൦\", \"൧\", \"൨\", \"൩\", \"൪\", \"൫\", \"൬\", \"൭\", \"൮\", \"൯\"],\n      mong: [\"᠐\", \"᠑\", \"᠒\", \"᠓\", \"᠔\", \"᠕\", \"᠖\", \"᠗\", \"᠘\", \"᠙\"],\n      mymr: [\"၀\", \"၁\", \"၂\", \"၃\", \"၄\", \"၅\", \"၆\", \"၇\", \"၈\", \"၉\"],\n      orya: [\"୦\", \"୧\", \"୨\", \"୩\", \"୪\", \"୫\", \"୬\", \"୭\", \"୮\", \"୯\"],\n      tamldec: [\"௦\", \"௧\", \"௨\", \"௩\", \"௪\", \"௫\", \"௬\", \"௭\", \"௮\", \"௯\"],\n      telu: [\"౦\", \"౧\", \"౨\", \"౩\", \"౪\", \"౫\", \"౬\", \"౭\", \"౮\", \"౯\"],\n      thai: [\"๐\", \"๑\", \"๒\", \"๓\", \"๔\", \"๕\", \"๖\", \"๗\", \"๘\", \"๙\"],\n      tibt: [\"༠\", \"༡\", \"༢\", \"༣\", \"༤\", \"༥\", \"༦\", \"༧\", \"༨\", \"༩\"]\n  };\n\n  /**\n   * This function provides access to the locale and formatting options computed\n   * during initialization of the object.\n   *\n   * The function returns a new object whose properties and attributes are set as\n   * if constructed by an object literal assigning to each of the following\n   * properties the value of the corresponding internal property of this\n   * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n   * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n   * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n   * useGrouping. Properties whose corresponding internal properties are not present\n   * are not assigned.\n   */\n  /* 11.3.3 */defineProperty(Intl$1.NumberFormat.prototype, 'resolvedOptions', {\n      configurable: true,\n      writable: true,\n      value: function value() {\n          var prop = void 0,\n              descs = new Record(),\n              props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n              internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n          // Satisfy test 11.3_b\n          if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n          for (var i = 0, max = props.length; i < max; i++) {\n              if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n          }\n\n          return objCreate({}, descs);\n      }\n  });\n\n  /* jslint esnext: true */\n\n  // Match these datetime components in a CLDR pattern, except those in single quotes\n  var expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n  // trim patterns after transformations\n  var expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n  // Skip over patterns with these datetime components because we don't have data\n  // to back them up:\n  // timezone, weekday, amoung others\n  var unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\n  var dtKeys = [\"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\n  var tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\n  function isDateFormatOnly(obj) {\n      for (var i = 0; i < tmKeys.length; i += 1) {\n          if (obj.hasOwnProperty(tmKeys[i])) {\n              return false;\n          }\n      }\n      return true;\n  }\n\n  function isTimeFormatOnly(obj) {\n      for (var i = 0; i < dtKeys.length; i += 1) {\n          if (obj.hasOwnProperty(dtKeys[i])) {\n              return false;\n          }\n      }\n      return true;\n  }\n\n  function joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n      var o = { _: {} };\n      for (var i = 0; i < dtKeys.length; i += 1) {\n          if (dateFormatObj[dtKeys[i]]) {\n              o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n          }\n          if (dateFormatObj._[dtKeys[i]]) {\n              o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n          }\n      }\n      for (var j = 0; j < tmKeys.length; j += 1) {\n          if (timeFormatObj[tmKeys[j]]) {\n              o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n          }\n          if (timeFormatObj._[tmKeys[j]]) {\n              o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n          }\n      }\n      return o;\n  }\n\n  function computeFinalPatterns(formatObj) {\n      // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n      //  'In patterns, two single quotes represents a literal single quote, either\n      //   inside or outside single quotes. Text within single quotes is not\n      //   interpreted in any way (except for two adjacent single quotes).'\n      formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n          return literal ? literal : \"'\";\n      });\n\n      // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n      formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n      return formatObj;\n  }\n\n  function expDTComponentsMeta($0, formatObj) {\n      switch ($0.charAt(0)) {\n          // --- Era\n          case 'G':\n              formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n              return '{era}';\n\n          // --- Year\n          case 'y':\n          case 'Y':\n          case 'u':\n          case 'U':\n          case 'r':\n              formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{year}';\n\n          // --- Quarter (not supported in this polyfill)\n          case 'Q':\n          case 'q':\n              formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n              return '{quarter}';\n\n          // --- Month\n          case 'M':\n          case 'L':\n              formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n              return '{month}';\n\n          // --- Week (not supported in this polyfill)\n          case 'w':\n              // week of the year\n              formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{weekday}';\n          case 'W':\n              // week of the month\n              formatObj.week = 'numeric';\n              return '{weekday}';\n\n          // --- Day\n          case 'd':\n              // day of the month\n              formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{day}';\n          case 'D': // day of the year\n          case 'F': // day of the week\n          case 'g':\n              // 1..n: Modified Julian day\n              formatObj.day = 'numeric';\n              return '{day}';\n\n          // --- Week Day\n          case 'E':\n              // day of the week\n              formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n              return '{weekday}';\n          case 'e':\n              // local day of the week\n              formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n              return '{weekday}';\n          case 'c':\n              // stand alone local day of the week\n              formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n              return '{weekday}';\n\n          // --- Period\n          case 'a': // AM, PM\n          case 'b': // am, pm, noon, midnight\n          case 'B':\n              // flexible day periods\n              formatObj.hour12 = true;\n              return '{ampm}';\n\n          // --- Hour\n          case 'h':\n          case 'H':\n              formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{hour}';\n          case 'k':\n          case 'K':\n              formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n              formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{hour}';\n\n          // --- Minute\n          case 'm':\n              formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{minute}';\n\n          // --- Second\n          case 's':\n              formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n              return '{second}';\n          case 'S':\n          case 'A':\n              formatObj.second = 'numeric';\n              return '{second}';\n\n          // --- Timezone\n          case 'z': // 1..3, 4: specific non-location format\n          case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n          case 'O': // 1, 4: miliseconds in day short, long\n          case 'v': // 1, 4: generic non-location format\n          case 'V': // 1, 2, 3, 4: time zone ID or city\n          case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n          case 'x':\n              // 1, 2, 3, 4: The ISO8601 varios formats\n              // this polyfill only supports much, for now, we are just doing something dummy\n              formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n              return '{timeZoneName}';\n      }\n  }\n\n  /**\n   * Converts the CLDR availableFormats into the objects and patterns required by\n   * the ECMAScript Internationalization API specification.\n   */\n  function createDateTimeFormat(skeleton, pattern) {\n      // we ignore certain patterns that are unsupported to avoid this expensive op.\n      if (unwantedDTCs.test(pattern)) return undefined;\n\n      var formatObj = {\n          originalPattern: pattern,\n          _: {}\n      };\n\n      // Replace the pattern string with the one required by the specification, whilst\n      // at the same time evaluating it for the subsets and formats\n      formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n          // See which symbol we're dealing with\n          return expDTComponentsMeta($0, formatObj._);\n      });\n\n      // Match the skeleton string with the one required by the specification\n      // this implementation is based on the Date Field Symbol Table:\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n      // Note: we are adding extra data to the formatObject even though this polyfill\n      //       might not support it.\n      skeleton.replace(expDTComponents, function ($0) {\n          // See which symbol we're dealing with\n          return expDTComponentsMeta($0, formatObj);\n      });\n\n      return computeFinalPatterns(formatObj);\n  }\n\n  /**\n   * Processes DateTime formats from CLDR to an easier-to-parse format.\n   * the result of this operation should be cached the first time a particular\n   * calendar is analyzed.\n   *\n   * The specification requires we support at least the following subsets of\n   * date/time components:\n   *\n   *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n   *   - 'weekday', 'year', 'month', 'day'\n   *   - 'year', 'month', 'day'\n   *   - 'year', 'month'\n   *   - 'month', 'day'\n   *   - 'hour', 'minute', 'second'\n   *   - 'hour', 'minute'\n   *\n   * We need to cherry pick at least these subsets from the CLDR data and convert\n   * them into the pattern objects used in the ECMA-402 API.\n   */\n  function createDateTimeFormats(formats) {\n      var availableFormats = formats.availableFormats;\n      var timeFormats = formats.timeFormats;\n      var dateFormats = formats.dateFormats;\n      var result = [];\n      var skeleton = void 0,\n          pattern = void 0,\n          computed = void 0,\n          i = void 0,\n          j = void 0;\n      var timeRelatedFormats = [];\n      var dateRelatedFormats = [];\n\n      // Map available (custom) formats into a pattern for createDateTimeFormats\n      for (skeleton in availableFormats) {\n          if (availableFormats.hasOwnProperty(skeleton)) {\n              pattern = availableFormats[skeleton];\n              computed = createDateTimeFormat(skeleton, pattern);\n              if (computed) {\n                  result.push(computed);\n                  // in some cases, the format is only displaying date specific props\n                  // or time specific props, in which case we need to also produce the\n                  // combined formats.\n                  if (isDateFormatOnly(computed)) {\n                      dateRelatedFormats.push(computed);\n                  } else if (isTimeFormatOnly(computed)) {\n                      timeRelatedFormats.push(computed);\n                  }\n              }\n          }\n      }\n\n      // Map time formats into a pattern for createDateTimeFormats\n      for (skeleton in timeFormats) {\n          if (timeFormats.hasOwnProperty(skeleton)) {\n              pattern = timeFormats[skeleton];\n              computed = createDateTimeFormat(skeleton, pattern);\n              if (computed) {\n                  result.push(computed);\n                  timeRelatedFormats.push(computed);\n              }\n          }\n      }\n\n      // Map date formats into a pattern for createDateTimeFormats\n      for (skeleton in dateFormats) {\n          if (dateFormats.hasOwnProperty(skeleton)) {\n              pattern = dateFormats[skeleton];\n              computed = createDateTimeFormat(skeleton, pattern);\n              if (computed) {\n                  result.push(computed);\n                  dateRelatedFormats.push(computed);\n              }\n          }\n      }\n\n      // combine custom time and custom date formats when they are orthogonals to complete the\n      // formats supported by CLDR.\n      // This Algo is based on section \"Missing Skeleton Fields\" from:\n      // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n      for (i = 0; i < timeRelatedFormats.length; i += 1) {\n          for (j = 0; j < dateRelatedFormats.length; j += 1) {\n              if (dateRelatedFormats[j].month === 'long') {\n                  pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n              } else if (dateRelatedFormats[j].month === 'short') {\n                  pattern = formats.medium;\n              } else {\n                  pattern = formats.short;\n              }\n              computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n              computed.originalPattern = pattern;\n              computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n              result.push(computeFinalPatterns(computed));\n          }\n      }\n\n      return result;\n  }\n\n  // this represents the exceptions of the rule that are not covered by CLDR availableFormats\n  // for single property configurations, they play no role when using multiple properties, and\n  // those that are not in this table, are not exceptions or are not covered by the data we\n  // provide.\n  var validSyntheticProps = {\n      second: {\n          numeric: 's',\n          '2-digit': 'ss'\n      },\n      minute: {\n          numeric: 'm',\n          '2-digit': 'mm'\n      },\n      year: {\n          numeric: 'y',\n          '2-digit': 'yy'\n      },\n      day: {\n          numeric: 'd',\n          '2-digit': 'dd'\n      },\n      month: {\n          numeric: 'L',\n          '2-digit': 'LL',\n          narrow: 'LLLLL',\n          short: 'LLL',\n          long: 'LLLL'\n      },\n      weekday: {\n          narrow: 'ccccc',\n          short: 'ccc',\n          long: 'cccc'\n      }\n  };\n\n  function generateSyntheticFormat(propName, propValue) {\n      if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {\n          var _ref2;\n\n          return _ref2 = {\n              originalPattern: validSyntheticProps[propName][propValue],\n              _: defineProperty$1({}, propName, propValue),\n              extendedPattern: \"{\" + propName + \"}\"\n          }, defineProperty$1(_ref2, propName, propValue), defineProperty$1(_ref2, \"pattern12\", \"{\" + propName + \"}\"), defineProperty$1(_ref2, \"pattern\", \"{\" + propName + \"}\"), _ref2;\n      }\n  }\n\n  // An object map of date component keys, saves using a regex later\n  var dateWidths = objCreate(null, { narrow: {}, short: {}, long: {} });\n\n  /**\n   * Returns a string for a date component, resolved using multiple inheritance as specified\n   * as specified in the Unicode Technical Standard 35.\n   */\n  function resolveDateString(data, ca, component, width, key) {\n      // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n      // 'In clearly specified instances, resources may inherit from within the same locale.\n      //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n      var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n\n\n      // \"sideways\" inheritance resolves strings when a key doesn't exist\n      alts = {\n          narrow: ['short', 'long'],\n          short: ['long', 'narrow'],\n          long: ['short', 'narrow']\n      },\n\n\n      //\n      resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]];\n\n      // `key` wouldn't be specified for components 'dayPeriods'\n      return key !== null ? resolved[key] : resolved;\n  }\n\n  // Define the DateTimeFormat constructor internally so it cannot be tainted\n  function DateTimeFormatConstructor() {\n      var locales = arguments[0];\n      var options = arguments[1];\n\n      if (!this || this === Intl$1) {\n          return new Intl$1.DateTimeFormat(locales, options);\n      }\n      return InitializeDateTimeFormat(toObject(this), locales, options);\n  }\n\n  defineProperty(Intl$1, 'DateTimeFormat', {\n      configurable: true,\n      writable: true,\n      value: DateTimeFormatConstructor\n  });\n\n  // Must explicitly set prototypes as unwritable\n  defineProperty(DateTimeFormatConstructor, 'prototype', {\n      writable: false\n  });\n\n  /**\n   * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n   * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n   * DateTimeFormat object.\n   */\n  function /* 12.1.1.1 */InitializeDateTimeFormat(dateTimeFormat, locales, options) {\n      // This will be a internal properties object if we're not already initialized\n      var internal = getInternalProperties(dateTimeFormat);\n\n      // Create an object whose props can be used to restore the values of RegExp props\n      var regexpRestore = createRegExpRestore();\n\n      // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n      //    value true, throw a TypeError exception.\n      if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n      // Need this to access the `internal` object\n      defineProperty(dateTimeFormat, '__getInternalProperties', {\n          value: function value() {\n              // NOTE: Non-standard, for internal use only\n              if (arguments[0] === secret) return internal;\n          }\n      });\n\n      // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n      internal['[[initializedIntlObject]]'] = true;\n\n      // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n      //    abstract operation (defined in 9.2.1) with argument locales.\n      var requestedLocales = CanonicalizeLocaleList(locales);\n\n      // 4. Let options be the result of calling the ToDateTimeOptions abstract\n      //    operation (defined below) with arguments options, \"any\", and \"date\".\n      options = ToDateTimeOptions(options, 'any', 'date');\n\n      // 5. Let opt be a new Record.\n      var opt = new Record();\n\n      // 6. Let matcher be the result of calling the GetOption abstract operation\n      //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n      //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n      var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n      // 7. Set opt.[[localeMatcher]] to matcher.\n      opt['[[localeMatcher]]'] = matcher;\n\n      // 8. Let DateTimeFormat be the standard built-in object that is the initial\n      //    value of Intl.DateTimeFormat.\n      var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n\n      // 9. Let localeData be the value of the [[localeData]] internal property of\n      //    DateTimeFormat.\n      var localeData = DateTimeFormat['[[localeData]]'];\n\n      // 10. Let r be the result of calling the ResolveLocale abstract operation\n      //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n      //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n      //      internal property of DateTimeFormat, and localeData.\n      var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n      // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n      //     r.[[locale]].\n      internal['[[locale]]'] = r['[[locale]]'];\n\n      // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n      //     r.[[ca]].\n      internal['[[calendar]]'] = r['[[ca]]'];\n\n      // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n      //     r.[[nu]].\n      internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n      // The specification doesn't tell us to do this, but it's helpful later on\n      internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n      // 14. Let dataLocale be the value of r.[[dataLocale]].\n      var dataLocale = r['[[dataLocale]]'];\n\n      // 15. Let tz be the result of calling the [[Get]] internal method of options with\n      //     argument \"timeZone\".\n      var tz = options.timeZone;\n\n      // 16. If tz is not undefined, then\n      if (tz !== undefined) {\n          // a. Let tz be ToString(tz).\n          // b. Convert tz to upper case as described in 6.1.\n          //    NOTE: If an implementation accepts additional time zone values, as permitted\n          //          under certain conditions by the Conformance clause, different casing\n          //          rules apply.\n          tz = toLatinUpperCase(tz);\n\n          // c. If tz is not \"UTC\", then throw a RangeError exception.\n          // ###TODO: accept more time zones###\n          if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n      }\n\n      // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n      internal['[[timeZone]]'] = tz;\n\n      // 18. Let opt be a new Record.\n      opt = new Record();\n\n      // 19. For each row of Table 3, except the header row, do:\n      for (var prop in dateTimeComponents) {\n          if (!hop.call(dateTimeComponents, prop)) continue;\n\n          // 20. Let prop be the name given in the Property column of the row.\n          // 21. Let value be the result of calling the GetOption abstract operation,\n          //     passing as argument options, the name given in the Property column of the\n          //     row, \"string\", a List containing the strings given in the Values column of\n          //     the row, and undefined.\n          var value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n          // 22. Set opt.[[<prop>]] to value.\n          opt['[[' + prop + ']]'] = value;\n      }\n\n      // Assigned a value below\n      var bestFormat = void 0;\n\n      // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n      //     localeData with argument dataLocale.\n      var dataLocaleData = localeData[dataLocale];\n\n      // 24. Let formats be the result of calling the [[Get]] internal method of\n      //     dataLocaleData with argument \"formats\".\n      //     Note: we process the CLDR formats into the spec'd structure\n      var formats = ToDateTimeFormats(dataLocaleData.formats);\n\n      // 25. Let matcher be the result of calling the GetOption abstract operation with\n      //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n      //     values \"basic\" and \"best fit\", and \"best fit\".\n      matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n      // Optimization: caching the processed formats as a one time operation by\n      // replacing the initial structure from localeData\n      dataLocaleData.formats = formats;\n\n      // 26. If matcher is \"basic\", then\n      if (matcher === 'basic') {\n          // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n          //     operation (defined below) with opt and formats.\n          bestFormat = BasicFormatMatcher(opt, formats);\n\n          // 28. Else\n      } else {\n          {\n              // diverging\n              var _hr = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n              opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n          }\n          // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n          //     abstract operation (defined below) with opt and formats.\n          bestFormat = BestFitFormatMatcher(opt, formats);\n      }\n\n      // 30. For each row in Table 3, except the header row, do\n      for (var _prop in dateTimeComponents) {\n          if (!hop.call(dateTimeComponents, _prop)) continue;\n\n          // a. Let prop be the name given in the Property column of the row.\n          // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n          //    bestFormat with argument prop.\n          // c. If pDesc is not undefined, then\n          if (hop.call(bestFormat, _prop)) {\n              // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n              //    with argument prop.\n              var p = bestFormat[_prop];\n              {\n                  // diverging\n                  p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n              }\n\n              // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n              internal['[[' + _prop + ']]'] = p;\n          }\n      }\n\n      var pattern = void 0; // Assigned a value below\n\n      // 31. Let hr12 be the result of calling the GetOption abstract operation with\n      //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n      var hr12 = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n\n      // 32. If dateTimeFormat has an internal property [[hour]], then\n      if (internal['[[hour]]']) {\n          // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n          //    internal method of dataLocaleData with argument \"hour12\".\n          hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n          // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n          internal['[[hour12]]'] = hr12;\n\n          // c. If hr12 is true, then\n          if (hr12 === true) {\n              // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n              //    dataLocaleData with argument \"hourNo0\".\n              var hourNo0 = dataLocaleData.hourNo0;\n\n              // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n              internal['[[hourNo0]]'] = hourNo0;\n\n              // iii. Let pattern be the result of calling the [[Get]] internal method of\n              //      bestFormat with argument \"pattern12\".\n              pattern = bestFormat.pattern12;\n          }\n\n          // d. Else\n          else\n              // i. Let pattern be the result of calling the [[Get]] internal method of\n              //    bestFormat with argument \"pattern\".\n              pattern = bestFormat.pattern;\n      }\n\n      // 33. Else\n      else\n          // a. Let pattern be the result of calling the [[Get]] internal method of\n          //    bestFormat with argument \"pattern\".\n          pattern = bestFormat.pattern;\n\n      // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n      internal['[[pattern]]'] = pattern;\n\n      // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n      internal['[[boundFormat]]'] = undefined;\n\n      // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n      //     true.\n      internal['[[initializedDateTimeFormat]]'] = true;\n\n      // In ES3, we need to pre-bind the format() function\n      if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n      // Restore the RegExp properties\n      regexpRestore();\n\n      // Return the newly initialised object\n      return dateTimeFormat;\n  }\n\n  /**\n   * Several DateTimeFormat algorithms use values from the following table, which provides\n   * property names and allowable values for the components of date and time formats:\n   */\n  var dateTimeComponents = {\n      weekday: [\"narrow\", \"short\", \"long\"],\n      era: [\"narrow\", \"short\", \"long\"],\n      year: [\"2-digit\", \"numeric\"],\n      month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n      day: [\"2-digit\", \"numeric\"],\n      hour: [\"2-digit\", \"numeric\"],\n      minute: [\"2-digit\", \"numeric\"],\n      second: [\"2-digit\", \"numeric\"],\n      timeZoneName: [\"short\", \"long\"]\n  };\n\n  /**\n   * When the ToDateTimeOptions abstract operation is called with arguments options,\n   * required, and defaults, the following steps are taken:\n   */\n  function ToDateTimeFormats(formats) {\n      if (Object.prototype.toString.call(formats) === '[object Array]') {\n          return formats;\n      }\n      return createDateTimeFormats(formats);\n  }\n\n  /**\n   * When the ToDateTimeOptions abstract operation is called with arguments options,\n   * required, and defaults, the following steps are taken:\n   */\n  function ToDateTimeOptions(options, required, defaults) {\n      // 1. If options is undefined, then let options be null, else let options be\n      //    ToObject(options).\n      if (options === undefined) options = null;else {\n          // (#12) options needs to be a Record, but it also needs to inherit properties\n          var opt2 = toObject(options);\n          options = new Record();\n\n          for (var k in opt2) {\n              options[k] = opt2[k];\n          }\n      }\n\n      // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n      var create = objCreate;\n\n      // 3. Let options be the result of calling the [[Call]] internal method of create with\n      //    undefined as the this value and an argument list containing the single item\n      //    options.\n      options = create(options);\n\n      // 4. Let needDefaults be true.\n      var needDefaults = true;\n\n      // 5. If required is \"date\" or \"any\", then\n      if (required === 'date' || required === 'any') {\n          // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n          // i. If the result of calling the [[Get]] internal method of options with the\n          //    property name is not undefined, then let needDefaults be false.\n          if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n      }\n\n      // 6. If required is \"time\" or \"any\", then\n      if (required === 'time' || required === 'any') {\n          // a. For each of the property names \"hour\", \"minute\", \"second\":\n          // i. If the result of calling the [[Get]] internal method of options with the\n          //    property name is not undefined, then let needDefaults be false.\n          if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n      }\n\n      // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n      if (needDefaults && (defaults === 'date' || defaults === 'all'))\n          // a. For each of the property names \"year\", \"month\", \"day\":\n          // i. Call the [[DefineOwnProperty]] internal method of options with the\n          //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n          //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n          options.year = options.month = options.day = 'numeric';\n\n      // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n      if (needDefaults && (defaults === 'time' || defaults === 'all'))\n          // a. For each of the property names \"hour\", \"minute\", \"second\":\n          // i. Call the [[DefineOwnProperty]] internal method of options with the\n          //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n          //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n          options.hour = options.minute = options.second = 'numeric';\n\n      // 9. Return options.\n      return options;\n  }\n\n  /**\n   * When the BasicFormatMatcher abstract operation is called with two arguments options and\n   * formats, the following steps are taken:\n   */\n  function BasicFormatMatcher(options, formats) {\n      // 1. Let removalPenalty be 120.\n      var removalPenalty = 120;\n\n      // 2. Let additionPenalty be 20.\n      var additionPenalty = 20;\n\n      // 3. Let longLessPenalty be 8.\n      var longLessPenalty = 8;\n\n      // 4. Let longMorePenalty be 6.\n      var longMorePenalty = 6;\n\n      // 5. Let shortLessPenalty be 6.\n      var shortLessPenalty = 6;\n\n      // 6. Let shortMorePenalty be 3.\n      var shortMorePenalty = 3;\n\n      // 7. Let bestScore be -Infinity.\n      var bestScore = -Infinity;\n\n      // 8. Let bestFormat be undefined.\n      var bestFormat = void 0;\n\n      // 9. Let i be 0.\n      var i = 0;\n\n      // 10. Assert: formats is an Array object.\n\n      // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n      var len = formats.length;\n\n      // 12. Repeat while i < len:\n      while (i < len) {\n          // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n          var format = formats[i];\n\n          // b. Let score be 0.\n          var score = 0;\n\n          // c. For each property shown in Table 3:\n          for (var property in dateTimeComponents) {\n              if (!hop.call(dateTimeComponents, property)) continue;\n\n              // i. Let optionsProp be options.[[<property>]].\n              var optionsProp = options['[[' + property + ']]'];\n\n              // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n              //     with argument property.\n              // iii. If formatPropDesc is not undefined, then\n              //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n              var formatProp = hop.call(format, property) ? format[property] : undefined;\n\n              // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n              //     additionPenalty.\n              if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n              // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n              //    removalPenalty.\n              else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                  // vi. Else\n                  else {\n                          // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                          //    \"long\"].\n                          var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                          // 2. Let optionsPropIndex be the index of optionsProp within values.\n                          var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                          // 3. Let formatPropIndex be the index of formatProp within values.\n                          var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                          // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                          var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                          // 5. If delta = 2, decrease score by longMorePenalty.\n                          if (delta === 2) score -= longMorePenalty;\n\n                          // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                          else if (delta === 1) score -= shortMorePenalty;\n\n                              // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                              else if (delta === -1) score -= shortLessPenalty;\n\n                                  // 8. Else if delta = -2, decrease score by longLessPenalty.\n                                  else if (delta === -2) score -= longLessPenalty;\n                      }\n          }\n\n          // d. If score > bestScore, then\n          if (score > bestScore) {\n              // i. Let bestScore be score.\n              bestScore = score;\n\n              // ii. Let bestFormat be format.\n              bestFormat = format;\n          }\n\n          // e. Increase i by 1.\n          i++;\n      }\n\n      // 13. Return bestFormat.\n      return bestFormat;\n  }\n\n  /**\n   * When the BestFitFormatMatcher abstract operation is called with two arguments options\n   * and formats, it performs implementation dependent steps, which should return a set of\n   * component representations that a typical user of the selected locale would perceive as\n   * at least as good as the one returned by BasicFormatMatcher.\n   *\n   * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n   * with the addition of bonus points awarded where the requested format is of\n   * the same data type as the potentially matching format.\n   *\n   * This algo relies on the concept of closest distance matching described here:\n   * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n   * Typically a “best match” is found using a closest distance match, such as:\n   *\n   * Symbols requesting a best choice for the locale are replaced.\n   *      j → one of {H, k, h, K}; C → one of {a, b, B}\n   * -> Covered by cldr.js matching process\n   *\n   * For fields with symbols representing the same type (year, month, day, etc):\n   *     Most symbols have a small distance from each other.\n   *         M ≅ L; E ≅ c; a ≅ b ≅ B; H ≅ k ≅ h ≅ K; ...\n   *     -> Covered by cldr.js matching process\n   *\n   *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n   *         MMM ≅ MMMM\n   *         MM ≅ M\n   *     Numeric and text fields are given a larger distance from each other.\n   *         MMM ≈ MM\n   *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n   *         d ≋ D; ...\n   *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n   *\n   *\n   * For example,\n   *\n   *     { month: 'numeric', day: 'numeric' }\n   *\n   * should match\n   *\n   *     { month: '2-digit', day: '2-digit' }\n   *\n   * rather than\n   *\n   *     { month: 'short', day: 'numeric' }\n   *\n   * This makes sense because a user requesting a formatted date with numeric parts would\n   * not expect to see the returned format containing narrow, short or long part names\n   */\n  function BestFitFormatMatcher(options, formats) {\n      /** Diverging: this block implements the hack for single property configuration, eg.:\n       *\n       *      `new Intl.DateTimeFormat('en', {day: 'numeric'})`\n       *\n       * should produce a single digit with the day of the month. This is needed because\n       * CLDR `availableFormats` data structure doesn't cover these cases.\n       */\n      {\n          var optionsPropNames = [];\n          for (var property in dateTimeComponents) {\n              if (!hop.call(dateTimeComponents, property)) continue;\n\n              if (options['[[' + property + ']]'] !== undefined) {\n                  optionsPropNames.push(property);\n              }\n          }\n          if (optionsPropNames.length === 1) {\n              var _bestFormat = generateSyntheticFormat(optionsPropNames[0], options['[[' + optionsPropNames[0] + ']]']);\n              if (_bestFormat) {\n                  return _bestFormat;\n              }\n          }\n      }\n\n      // 1. Let removalPenalty be 120.\n      var removalPenalty = 120;\n\n      // 2. Let additionPenalty be 20.\n      var additionPenalty = 20;\n\n      // 3. Let longLessPenalty be 8.\n      var longLessPenalty = 8;\n\n      // 4. Let longMorePenalty be 6.\n      var longMorePenalty = 6;\n\n      // 5. Let shortLessPenalty be 6.\n      var shortLessPenalty = 6;\n\n      // 6. Let shortMorePenalty be 3.\n      var shortMorePenalty = 3;\n\n      var patternPenalty = 2;\n\n      var hour12Penalty = 1;\n\n      // 7. Let bestScore be -Infinity.\n      var bestScore = -Infinity;\n\n      // 8. Let bestFormat be undefined.\n      var bestFormat = void 0;\n\n      // 9. Let i be 0.\n      var i = 0;\n\n      // 10. Assert: formats is an Array object.\n\n      // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n      var len = formats.length;\n\n      // 12. Repeat while i < len:\n      while (i < len) {\n          // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n          var format = formats[i];\n\n          // b. Let score be 0.\n          var score = 0;\n\n          // c. For each property shown in Table 3:\n          for (var _property in dateTimeComponents) {\n              if (!hop.call(dateTimeComponents, _property)) continue;\n\n              // i. Let optionsProp be options.[[<property>]].\n              var optionsProp = options['[[' + _property + ']]'];\n\n              // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n              //     with argument property.\n              // iii. If formatPropDesc is not undefined, then\n              //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n              var formatProp = hop.call(format, _property) ? format[_property] : undefined;\n\n              // Diverging: using the default properties produced by the pattern/skeleton\n              // to match it with user options, and apply a penalty\n              var patternProp = hop.call(format._, _property) ? format._[_property] : undefined;\n              if (optionsProp !== patternProp) {\n                  score -= patternPenalty;\n              }\n\n              // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n              //     additionPenalty.\n              if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n              // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n              //    removalPenalty.\n              else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                  // vi. Else\n                  else {\n                          // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                          //    \"long\"].\n                          var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                          // 2. Let optionsPropIndex be the index of optionsProp within values.\n                          var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                          // 3. Let formatPropIndex be the index of formatProp within values.\n                          var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                          // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                          var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                          {\n                              // diverging from spec\n                              // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                              if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n                                  // 5. If delta = 2, decrease score by longMorePenalty.\n                                  if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n                              } else {\n                                  // 5. If delta = 2, decrease score by longMorePenalty.\n                                  if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n                              }\n                          }\n                      }\n          }\n\n          {\n              // diverging to also take into consideration differences between 12 or 24 hours\n              // which is special for the best fit only.\n              if (format._.hour12 !== options.hour12) {\n                  score -= hour12Penalty;\n              }\n          }\n\n          // d. If score > bestScore, then\n          if (score > bestScore) {\n              // i. Let bestScore be score.\n              bestScore = score;\n              // ii. Let bestFormat be format.\n              bestFormat = format;\n          }\n\n          // e. Increase i by 1.\n          i++;\n      }\n\n      // 13. Return bestFormat.\n      return bestFormat;\n  }\n\n  /* 12.2.3 */internals.DateTimeFormat = {\n      '[[availableLocales]]': [],\n      '[[relevantExtensionKeys]]': ['ca', 'nu'],\n      '[[localeData]]': {}\n  };\n\n  /**\n   * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n   * following steps are taken:\n   */\n  /* 12.2.2 */\n  defineProperty(Intl$1.DateTimeFormat, 'supportedLocalesOf', {\n      configurable: true,\n      writable: true,\n      value: fnBind.call(function (locales) {\n          // Bound functions only have the `this` value altered if being used as a constructor,\n          // this lets us imitate a native function that has no constructor\n          if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n          // Create an object whose props can be used to restore the values of RegExp props\n          var regexpRestore = createRegExpRestore(),\n\n\n          // 1. If options is not provided, then let options be undefined.\n          options = arguments[1],\n\n\n          // 2. Let availableLocales be the value of the [[availableLocales]] internal\n          //    property of the standard built-in object that is the initial value of\n          //    Intl.NumberFormat.\n\n          availableLocales = this['[[availableLocales]]'],\n\n\n          // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n          //    abstract operation (defined in 9.2.1) with argument locales.\n          requestedLocales = CanonicalizeLocaleList(locales);\n\n          // Restore the RegExp properties\n          regexpRestore();\n\n          // 4. Return the result of calling the SupportedLocales abstract operation\n          //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n          //    and options.\n          return SupportedLocales(availableLocales, requestedLocales, options);\n      }, internals.NumberFormat)\n  });\n\n  /**\n   * This named accessor property returns a function that formats a number\n   * according to the effective locale and the formatting options of this\n   * DateTimeFormat object.\n   */\n  /* 12.3.2 */defineProperty(Intl$1.DateTimeFormat.prototype, 'format', {\n      configurable: true,\n      get: GetFormatDateTime\n  });\n\n  function GetFormatDateTime() {\n      var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n      // Satisfy test 12.3_b\n      if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n      // The value of the [[Get]] attribute is a function that takes the following\n      // steps:\n\n      // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n      //    is undefined, then:\n      if (internal['[[boundFormat]]'] === undefined) {\n          // a. Let F be a Function object, with internal properties set as\n          //    specified for built-in functions in ES5, 15, or successor, and the\n          //    length property set to 0, that takes the argument date and\n          //    performs the following steps:\n          var F = function F() {\n              var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n              //   i. If date is not provided or is undefined, then let x be the\n              //      result as if by the expression Date.now() where Date.now is\n              //      the standard built-in function defined in ES5, 15.9.4.4.\n              //  ii. Else let x be ToNumber(date).\n              // iii. Return the result of calling the FormatDateTime abstract\n              //      operation (defined below) with arguments this and x.\n              var x = date === undefined ? Date.now() : toNumber(date);\n              return FormatDateTime(this, x);\n          };\n          // b. Let bind be the standard built-in function object defined in ES5,\n          //    15.3.4.5.\n          // c. Let bf be the result of calling the [[Call]] internal method of\n          //    bind with F as the this value and an argument list containing\n          //    the single item this.\n          var bf = fnBind.call(F, this);\n          // d. Set the [[boundFormat]] internal property of this NumberFormat\n          //    object to bf.\n          internal['[[boundFormat]]'] = bf;\n      }\n      // Return the value of the [[boundFormat]] internal property of this\n      // NumberFormat object.\n      return internal['[[boundFormat]]'];\n  }\n\n  function formatToParts$1() {\n      var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n      var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n      if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n\n      var x = date === undefined ? Date.now() : toNumber(date);\n      return FormatToPartsDateTime(this, x);\n  }\n\n  Object.defineProperty(Intl$1.DateTimeFormat.prototype, 'formatToParts', {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: formatToParts$1\n  });\n\n  function CreateDateTimeParts(dateTimeFormat, x) {\n      // 1. If x is not a finite Number, then throw a RangeError exception.\n      if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\n      var internal = dateTimeFormat.__getInternalProperties(secret);\n\n      // Creating restore point for properties on the RegExp object... please wait\n      /* let regexpRestore = */createRegExpRestore(); // ###TODO: review this\n\n      // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n      var locale = internal['[[locale]]'];\n\n      // 3. Let nf be the result of creating a new NumberFormat object as if by the\n      // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n      // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n      var nf = new Intl$1.NumberFormat([locale], { useGrouping: false });\n\n      // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n      // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n      // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n      // 11.1.3.\n      var nf2 = new Intl$1.NumberFormat([locale], { minimumIntegerDigits: 2, useGrouping: false });\n\n      // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n      // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n      // and the value of the [[timeZone]] internal property of dateTimeFormat.\n      var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\n\n      // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n      var pattern = internal['[[pattern]]'];\n\n      // 7.\n      var result = new List();\n\n      // 8.\n      var index = 0;\n\n      // 9.\n      var beginIndex = pattern.indexOf('{');\n\n      // 10.\n      var endIndex = 0;\n\n      // Need the locale minus any extensions\n      var dataLocale = internal['[[dataLocale]]'];\n\n      // Need the calendar data from CLDR\n      var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n      var ca = internal['[[calendar]]'];\n\n      // 11.\n      while (beginIndex !== -1) {\n          var fv = void 0;\n          // a.\n          endIndex = pattern.indexOf('}', beginIndex);\n          // b.\n          if (endIndex === -1) {\n              throw new Error('Unclosed pattern');\n          }\n          // c.\n          if (beginIndex > index) {\n              arrPush.call(result, {\n                  type: 'literal',\n                  value: pattern.substring(index, beginIndex)\n              });\n          }\n          // d.\n          var p = pattern.substring(beginIndex + 1, endIndex);\n          // e.\n          if (dateTimeComponents.hasOwnProperty(p)) {\n              //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n              var f = internal['[[' + p + ']]'];\n              //  ii. Let v be the value of tm.[[<p>]].\n              var v = tm['[[' + p + ']]'];\n              // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\n              if (p === 'year' && v <= 0) {\n                  v = 1 - v;\n              }\n              //  iv. If p is \"month\", then increase v by 1.\n              else if (p === 'month') {\n                      v++;\n                  }\n                  //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n                  //      dateTimeFormat is true, then\n                  else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                          // 1. Let v be v modulo 12.\n                          v = v % 12;\n                          // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n                          //    dateTimeFormat is true, then let v be 12.\n                          if (v === 0 && internal['[[hourNo0]]'] === true) {\n                              v = 12;\n                          }\n                      }\n\n              //  vi. If f is \"numeric\", then\n              if (f === 'numeric') {\n                  // 1. Let fv be the result of calling the FormatNumber abstract operation\n                  //    (defined in 11.3.2) with arguments nf and v.\n                  fv = FormatNumber(nf, v);\n              }\n              // vii. Else if f is \"2-digit\", then\n              else if (f === '2-digit') {\n                      // 1. Let fv be the result of calling the FormatNumber abstract operation\n                      //    with arguments nf2 and v.\n                      fv = FormatNumber(nf2, v);\n                      // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                      //    containing the last two characters.\n                      if (fv.length > 2) {\n                          fv = fv.slice(-2);\n                      }\n                  }\n                  // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n                  //     value representing f in the desired form; the String value depends upon\n                  //     the implementation and the effective locale and calendar of\n                  //     dateTimeFormat. If p is \"month\", then the String value may also depend\n                  //     on whether dateTimeFormat has a [[day]] internal property. If p is\n                  //     \"timeZoneName\", then the String value may also depend on the value of\n                  //     the [[inDST]] field of tm.\n                  else if (f in dateWidths) {\n                          switch (p) {\n                              case 'month':\n                                  fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n                                  break;\n\n                              case 'weekday':\n                                  try {\n                                      fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']);\n                                      // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                                  } catch (e) {\n                                      throw new Error('Could not find weekday data for locale ' + locale);\n                                  }\n                                  break;\n\n                              case 'timeZoneName':\n                                  fv = ''; // ###TODO\n                                  break;\n\n                              case 'era':\n                                  try {\n                                      fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n                                  } catch (e) {\n                                      throw new Error('Could not find era data for locale ' + locale);\n                                  }\n                                  break;\n\n                              default:\n                                  fv = tm['[[' + p + ']]'];\n                          }\n                      }\n              // ix\n              arrPush.call(result, {\n                  type: p,\n                  value: fv\n              });\n              // f.\n          } else if (p === 'ampm') {\n              // i.\n              var _v = tm['[[hour]]'];\n              // ii./iii.\n              fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null);\n              // iv.\n              arrPush.call(result, {\n                  type: 'dayPeriod',\n                  value: fv\n              });\n              // g.\n          } else {\n              arrPush.call(result, {\n                  type: 'literal',\n                  value: pattern.substring(beginIndex, endIndex + 1)\n              });\n          }\n          // h.\n          index = endIndex + 1;\n          // i.\n          beginIndex = pattern.indexOf('{', index);\n      }\n      // 12.\n      if (endIndex < pattern.length - 1) {\n          arrPush.call(result, {\n              type: 'literal',\n              value: pattern.substr(endIndex + 1)\n          });\n      }\n      // 13.\n      return result;\n  }\n\n  /**\n   * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n   * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n   * value), it returns a String value representing x (interpreted as a time value as\n   * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n   * options of dateTimeFormat.\n   */\n  function FormatDateTime(dateTimeFormat, x) {\n      var parts = CreateDateTimeParts(dateTimeFormat, x);\n      var result = '';\n\n      for (var i = 0; parts.length > i; i++) {\n          var part = parts[i];\n          result += part.value;\n      }\n      return result;\n  }\n\n  function FormatToPartsDateTime(dateTimeFormat, x) {\n      var parts = CreateDateTimeParts(dateTimeFormat, x);\n      var result = [];\n      for (var i = 0; parts.length > i; i++) {\n          var part = parts[i];\n          result.push({\n              type: part.type,\n              value: part.value\n          });\n      }\n      return result;\n  }\n\n  /**\n   * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n   * timeZone, the following steps are taken:\n   */\n  function ToLocalTime(date, calendar, timeZone) {\n      // 1. Apply calendrical calculations on date for the given calendar and time zone to\n      //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n      //    The calculations should use best available information about the specified\n      //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n      //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n      //    bound by the restrictions on the use of best available information on time zones\n      //    for local time zone adjustment and daylight saving time adjustment imposed by\n      //    ES5, 15.9.1.7 and 15.9.1.8.\n      // ###TODO###\n      var d = new Date(date),\n          m = 'get' + (timeZone || '');\n\n      // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n      //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n      //    calculated value.\n      return new Record({\n          '[[weekday]]': d[m + 'Day'](),\n          '[[era]]': +(d[m + 'FullYear']() >= 0),\n          '[[year]]': d[m + 'FullYear'](),\n          '[[month]]': d[m + 'Month'](),\n          '[[day]]': d[m + 'Date'](),\n          '[[hour]]': d[m + 'Hours'](),\n          '[[minute]]': d[m + 'Minutes'](),\n          '[[second]]': d[m + 'Seconds'](),\n          '[[inDST]]': false // ###TODO###\n      });\n  }\n\n  /**\n   * The function returns a new object whose properties and attributes are set as if\n   * constructed by an object literal assigning to each of the following properties the\n   * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n   * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n   * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n   * properties are not present are not assigned.\n   */\n  /* 12.3.3 */defineProperty(Intl$1.DateTimeFormat.prototype, 'resolvedOptions', {\n      writable: true,\n      configurable: true,\n      value: function value() {\n          var prop = void 0,\n              descs = new Record(),\n              props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n              internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n          // Satisfy test 12.3_b\n          if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n          for (var i = 0, max = props.length; i < max; i++) {\n              if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n          }\n\n          return objCreate({}, descs);\n      }\n  });\n\n  var ls = Intl$1.__localeSensitiveProtos = {\n      Number: {},\n      Date: {}\n  };\n\n  /**\n   * When the toLocaleString method is called with optional arguments locales and options,\n   * the following steps are taken:\n   */\n  /* 13.2.1 */ls.Number.toLocaleString = function () {\n      // Satisfy test 13.2.1_1\n      if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n      // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n      // 2. If locales is not provided, then let locales be undefined.\n      // 3. If options is not provided, then let options be undefined.\n      // 4. Let numberFormat be the result of creating a new object as if by the\n      //    expression new Intl.NumberFormat(locales, options) where\n      //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n      // 5. Return the result of calling the FormatNumber abstract operation\n      //    (defined in 11.3.2) with arguments numberFormat and x.\n      return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n  };\n\n  /**\n   * When the toLocaleString method is called with optional arguments locales and options,\n   * the following steps are taken:\n   */\n  /* 13.3.1 */ls.Date.toLocaleString = function () {\n      // Satisfy test 13.3.0_1\n      if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n      // 1. Let x be this time value (as defined in ES5, 15.9.5).\n      var x = +this;\n\n      // 2. If x is NaN, then return \"Invalid Date\".\n      if (isNaN(x)) return 'Invalid Date';\n\n      // 3. If locales is not provided, then let locales be undefined.\n      var locales = arguments[0];\n\n      // 4. If options is not provided, then let options be undefined.\n      var options = arguments[1];\n\n      // 5. Let options be the result of calling the ToDateTimeOptions abstract\n      //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n      options = ToDateTimeOptions(options, 'any', 'all');\n\n      // 6. Let dateTimeFormat be the result of creating a new object as if by the\n      //    expression new Intl.DateTimeFormat(locales, options) where\n      //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n      // 7. Return the result of calling the FormatDateTime abstract operation (defined\n      //    in 12.3.2) with arguments dateTimeFormat and x.\n      return FormatDateTime(dateTimeFormat, x);\n  };\n\n  /**\n   * When the toLocaleDateString method is called with optional arguments locales and\n   * options, the following steps are taken:\n   */\n  /* 13.3.2 */ls.Date.toLocaleDateString = function () {\n      // Satisfy test 13.3.0_1\n      if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n      // 1. Let x be this time value (as defined in ES5, 15.9.5).\n      var x = +this;\n\n      // 2. If x is NaN, then return \"Invalid Date\".\n      if (isNaN(x)) return 'Invalid Date';\n\n      // 3. If locales is not provided, then let locales be undefined.\n      var locales = arguments[0],\n\n\n      // 4. If options is not provided, then let options be undefined.\n      options = arguments[1];\n\n      // 5. Let options be the result of calling the ToDateTimeOptions abstract\n      //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n      options = ToDateTimeOptions(options, 'date', 'date');\n\n      // 6. Let dateTimeFormat be the result of creating a new object as if by the\n      //    expression new Intl.DateTimeFormat(locales, options) where\n      //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n      // 7. Return the result of calling the FormatDateTime abstract operation (defined\n      //    in 12.3.2) with arguments dateTimeFormat and x.\n      return FormatDateTime(dateTimeFormat, x);\n  };\n\n  /**\n   * When the toLocaleTimeString method is called with optional arguments locales and\n   * options, the following steps are taken:\n   */\n  /* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n      // Satisfy test 13.3.0_1\n      if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n      // 1. Let x be this time value (as defined in ES5, 15.9.5).\n      var x = +this;\n\n      // 2. If x is NaN, then return \"Invalid Date\".\n      if (isNaN(x)) return 'Invalid Date';\n\n      // 3. If locales is not provided, then let locales be undefined.\n      var locales = arguments[0];\n\n      // 4. If options is not provided, then let options be undefined.\n      var options = arguments[1];\n\n      // 5. Let options be the result of calling the ToDateTimeOptions abstract\n      //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n      options = ToDateTimeOptions(options, 'time', 'time');\n\n      // 6. Let dateTimeFormat be the result of creating a new object as if by the\n      //    expression new Intl.DateTimeFormat(locales, options) where\n      //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n      var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n      // 7. Return the result of calling the FormatDateTime abstract operation (defined\n      //    in 12.3.2) with arguments dateTimeFormat and x.\n      return FormatDateTime(dateTimeFormat, x);\n  };\n\n  defineProperty(Intl$1, '__applyLocaleSensitivePrototypes', {\n      writable: true,\n      configurable: true,\n      value: function value() {\n          defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n          // Need this here for IE 8, to avoid the _DontEnum_ bug\n          defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n          for (var k in ls.Date) {\n              if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n          }\n      }\n  });\n\n  /**\n   * Can't really ship a single script with data for hundreds of locales, so we provide\n   * this __addLocaleData method as a means for the developer to add the data on an\n   * as-needed basis\n   */\n  defineProperty(Intl$1, '__addLocaleData', {\n      value: function value(data) {\n          if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n          addLocaleData(data, data.locale);\n      }\n  });\n\n  function addLocaleData(data, tag) {\n      // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n      if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n      var locale = void 0,\n          locales = [tag],\n          parts = tag.split('-');\n\n      // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n      if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n      while (locale = arrShift.call(locales)) {\n          // Add to NumberFormat internal properties as per 11.2.3\n          arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n          internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n          // ...and DateTimeFormat internal properties as per 12.2.3\n          if (data.date) {\n              data.date.nu = data.number.nu;\n              arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n              internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n          }\n      }\n\n      // If this is the first set of locale data added, make it the default\n      if (defaultLocale === undefined) setDefaultLocale(tag);\n  }\n\n  defineProperty(Intl$1, '__disableRegExpRestore', {\n      value: function value() {\n          internals.disableRegExpRestore = true;\n      }\n  });\n\n  // hack to export the polyfill as global Intl if needed\n  if (typeof Intl === 'undefined') {\n      try {\n          window.Intl = Intl$1;\n          Intl$1.__applyLocaleSensitivePrototypes();\n      } catch (e) {\n          // can be read only property\n      }\n  }\n\n  return Intl$1;\n\n}));\n//# =Intl.js.map"]}